/* This file defines the transition matrix for one of several empirical input model for amino-acids.
   The file should be used as follows:
   
   1) Read Data File and create datafilter filteredData
   2) #include this file (or use SelectTemplateModel(filteredData);)
   3) Define the tree
   4) Proceed with the likelihood function using 'vectorOfFrequencies' as the vector to pass to the constructor.
   
   This model has the following signature:
   	#Short:Empirical#
   	#Desc:One of the empirical models for amino-acids#
   	#Dimension:20#
    #DataType:aminoacid#
   	#FileName:Empirical.mdl#
   
   10/13/2008  by Sergei L. Kosakovsky Pond
*/

NICETY_LEVEL = 2;

#include "modelParameters2.mdl";

FREQUENCY_SENSITIVE = 1;

if (!SKIP_MODEL_PARAMETER_LIST)
{
	ExecuteAFile 			("AAModels/modellist.ibf");
	
	selectedModelMatrix = 	generateSelectionList();
	ChoiceList (selectedModelMatrix,"Choose An Empirical Matrix",1,SKIP_NONE,selectedModelMatrix);
	
	if (selectedModelMatrix < 0)
	{
		return -1;
	}
	
	_hasEFV = (models[selectedModelMatrix])["HasFrequencies"];
	
	if (_hasEFV)
	{
		ChoiceList (FREQUENCY_SENSITIVE,"Base frequencies",1,SKIP_NONE,"Fixed","Frequencies are fixed from the training dataset or the estimation procedure",
																       "Empirical (+F)", "Frequencies are tabulated from the sequence alignment (the +F option in literature)");
		
		if (FREQUENCY_SENSITIVE < 0)
		{
			return -1;
		}
		fscanf ("AAModels/" + (models[selectedModelMatrix])["File"], "String,NMatrix,NMatrix",aaOrder,_eRateMatrix,_eEFV);
	}
	else
	{
		fscanf ("AAModels/" + (models[selectedModelMatrix])["File"], "String,NMatrix",aaOrder,_eRateMatrix);	
	}

	if (modelType == 1)
	{
		#include "defineGamma.mdl";
	}	
	if (modelType == 2)
	{
		#include "defineHM.mdl";
	}
}

function PopulateModelMatrix (ModelMatrixName&, EFV)
{
	ModelMatrixName = {20,20};
	if (modelType == 0)
	{
		for (h = 0; h < 20; h=h+1)
		{
			for (v = h+1; v < 20; v=v+1)
			{
				ModelMatrixName[h][v] := t*_eRateMatrix__[h][v];
				ModelMatrixName[v][h] := t*_eRateMatrix__[v][h];
			}
		}	
	}
	else
	{
		for (h = 0; h < 20; h=h+1)
		{
			for (v = h+1; v < 20; v=v+1)
			{
				ModelMatrixName[h][v] := c*t*_eRateMatrix__[h][v];
				ModelMatrixName[v][h] := c*t*_eRateMatrix__[v][h];
			}
		}	
	
	}
	return 1;
}

if (FREQUENCY_SENSITIVE)
{
	HarvestFrequencies 						(vectorOfFrequencies,filteredData,1,1,0);
	MULTIPLY_BY_FREQS = PopulateModelMatrix ("EEAA",vectorOfFrequencies);
	Model EmpiricalAAModel 					= (EEAA, vectorOfFrequencies);
}
else
{
	MULTIPLY_BY_FREQS = PopulateModelMatrix ("EEAA",equalFreqs);
	Model EmpiricalAAModel 					= (EEAA, equalFreqs);
}

