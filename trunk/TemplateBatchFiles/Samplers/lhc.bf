/*---------------------------------------------------------------------------------------------------------------------*/LoadFunctionLibrary ("GrabBag");varCount = Abs (COVARIANCE_PARAMETER);usedVars = Rows(COVARIANCE_PARAMETER);inflationFactor = prompt_for_a_value ("Inflation factor for profile likelihood bounds", 2.0, 0.0, 1000.0, 0);fprintf (stdout, "\nObtaining profile likeihood bounds...\n");svpc = COVARIANCE_PRECISION;COVARIANCE_PRECISION = 0.95;if (MPI_NODE_COUNT > 2 && varCount > 1){	availableComputeNodes = Min(MPI_NODE_COUNT - 1,varCount);		currentIndex = 0;		mapper		 = {};	dispatched   = {};		for (k = 0; k < varCount; k+=1)	{		mapper [usedVars[k]] = k;	}		for (nodeIndex = 0; nodeIndex < availableComputeNodes; nodeIndex += 1)	{		localCovarianceParameters = {};		for (currentIndex = nodeIndex; currentIndex < varCount; currentIndex += availableComputeNodes)		{			localCovarianceParameters[usedVars[currentIndex]] = 1;		}				LF_NEXUS_EXPORT_EXTRA = "COVARIANCE_PARAMETER = " + localCovarianceParameters + 							  ";\nCOVARIANCE_PRECISION = 0.95;\nCovarianceMatrix (MPI_NEXUS_FILE_RETURN, `LF_NAME`);fprintf (stdout, MPI_NEXUS_FILE_RETURN);";				ExecuteCommands ("Export (lfString, `LF_NAME`);");		dispatched [nodeIndex+1] = localCovarianceParameters;		MPISend (nodeIndex+1, lfString);	}		covMx = {varCount, 3};		for (nodeIndex = 0; nodeIndex < availableComputeNodes; nodeIndex += 1)	{		MPIReceive  (-1, fromNode, res);		Eval ("nodeMx="+res);		varNames = Rows(dispatched [fromNode]);		for (k = 0; k < Columns (varNames); k+=1)		{			k2			 = mapper[varNames[k]];			covMx[k2][0] = nodeMx[k][0];			covMx[k2][1] = nodeMx[k][1];			covMx[k2][2] = nodeMx[k][2];		}	}}else{	ExecuteCommands ("CovarianceMatrix (covMx, `LF_NAME`);");	profileString = "";	profileString * 128;	profileString * "Parameter, Lower Bound, MLE, Upper Bound";	for (k=0; k<varCount; k=k+1)	{		profileString * ("\n"+usedVars[k]+","+covMx[k][0]+","+covMx[k][1]+","+covMx[k][2]);	}	profileString * 0;}k = baseResPath+".profile";fprintf (k,CLEAR_FILE,profileString);profileString = 0;COVARIANCE_PRECISION = svpc;stashedValues = {varCount,4};assignmentString = "";assignmentString * 256;variableValues   = {};for (k=0; k<varCount; k=k+1){	aKey 			    = usedVars[k];	ExecuteCommands 	("GetInformation(varRange,"+aKey+");");	stashedValues[k][0] = covMx[k][1];	/* compute the variance of the approximate normal to the left */	leftSTD 		= (covMx[k][1]-covMx[k][0])/1.96 * inflationFactor;	rightSTD		= (covMx[k][2]-covMx[k][1])/1.96 * inflationFactor;	if (leftSTD)	{		SAMPLE_LEFT = Min(1,(covMx[k][1]-varRange[1])/(1.96*leftSTD));		leftSpan	= Min(covMx[k][1]-varRange[1],1.96*leftSTD);	}	else	{		SAMPLE_LEFT = 0;	}	if (rightSTD)	{		SAMPLE_RIGHT = Min(1,(varRange[2]-covMx[k][1])/(1.96*rightSTD));		rightSpan	 = Min(varRange[2]-covMx[k][1],1.96*rightSTD);	}	else	{		SAMPLE_RIGHT = 0;	}        	thisVarValues = {SAMPLE_N,1};    if (SAMPLE_LEFT + SAMPLE_RIGHT)    {        SAMPLE_LEFT  = SAMPLE_N * (SAMPLE_LEFT)/(SAMPLE_LEFT+SAMPLE_RIGHT) $1;        SAMPLE_RIGHT = SAMPLE_N - SAMPLE_LEFT;                        /*        fprintf (stdout, aKey, ":", leftSTD, "/", rightSTD, "; ", SAMPLE_LEFT, "-", SAMPLE_RIGHT, "\n",leftSpan,"\n",varRange,"\n");        */                if (SAMPLE_LEFT)        {            if (SAMPLE_LEFT == SAMPLE_N)            {                SAMPLE_LEFT = SAMPLE_LEFT-1;            }                        weight = 1/SAMPLE_LEFT*(ZCDF (leftSpan/leftSTD)-ZCDF(0));                        FindRoot(z, ZCDF(x/leftSTD)-0.5-weight,x,0,leftSpan);            thisVarValues[SAMPLE_LEFT-1] = z;            for (ss = SAMPLE_LEFT-2; ss >= 0; ss = ss - 1)            {                FindRoot(z, ZCDF(x/leftSTD)-ZCDF(thisVarValues[ss+1]/leftSTD)-weight,x,thisVarValues[ss+1],leftSpan);                thisVarValues[ss] = z;            }            for (ss = SAMPLE_LEFT-1; ss >= 0; ss = ss - 1)            {                thisVarValues[ss] = covMx[k][1] - thisVarValues[ss];            }        }	        if (SAMPLE_RIGHT)        {            weight = 1/SAMPLE_RIGHT*(ZCDF (rightSpan/rightSTD)-ZCDF(0));            for (ss = SAMPLE_LEFT+1; ss < SAMPLE_N; ss = ss + 1)            {                FindRoot(z, ZCDF(x/rightSTD)-ZCDF(thisVarValues[ss-1]/rightSTD)-weight,x,thisVarValues[ss-1],rightSpan);                thisVarValues[ss] = z;            }            for (ss = SAMPLE_LEFT+1; ss < SAMPLE_N; ss = ss + 1)            {                thisVarValues[ss] = covMx[k][1] + thisVarValues[ss];            }        }	    }    else    {        thisVarValues = thisVarValues["covMx[k][1]"];    }    	thisVarValues [SAMPLE_LEFT] = covMx[k][1];		stashedValues[k][1] = Max(covMx[k][1]-(covMx[k][1]-covMx[k][0])*inflationFactor,varRange[1]);	stashedValues[k][2] = Min(covMx[k][1]+(covMx[k][2]-covMx[k][1])*inflationFactor,varRange[2]);	stashedValues[k][3] = (stashedValues[k][2]-stashedValues[k][1])/SAMPLE_N;	assignmentString * (aKey+ "=generatedSamples[itCount]["+k+"];\n");	variableValues[k]   = thisVarValues;}assignmentString * 0;varCount	= Rows (covMx);generatedSamples = {SAMPLE_N,varCount};indexVector		 = {1,SAMPLE_N}["_MATRIX_ELEMENT_COLUMN_"];fprintf (stdout, "\nDoing Latin hypercube sampling...\n");for (k=0; k<varCount; k=k+1){	permVector = Random (indexVector,0);	lb = stashedValues[k][1];	st = stashedValues[k][3];	for (m = 0; m<SAMPLE_N; m=m+1)	{		generatedSamples[m][k] = (variableValues[k])[permVector[m]];	}}/*fprintf ("/Users/sergei/Desktop/cubedump.bf", CLEAR_FILE, "generatedSamples = ", generatedSamples, ";\nnames = ", usedVars, ";\n", assignmentString, "\n");*/#include "srs.ibf";