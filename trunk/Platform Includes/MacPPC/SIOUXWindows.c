/*  Metrowerks Standard Library  *//*  $Date: 1999/12/06 20:46:25 $  *  $Revision: 1.3 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//*****************************************************************************//*  Project...: C++ and ANSI-C Compiler Environment                          *//*  Name......: SIOUXWindows.c                                       	     *//*  Purpose...: Menu related functions for SIOUX			                 *//*****************************************************************************/ #include <SIOUX.h>#include "SIOUXGlobals.h"#include "SIOUXWindows.h"#if SIOUX_USE_WASTE	#include "LongControls.h"		/* ¥¥¥LC */#endif /* SIOUX_USE_WASTE */#include <string.h>#include <Icons.h>#include <Processes.h>#include <Sound.h>               /* mm 971006 */#include <LowMem.h> /*bkoz*/#include <ToolUtils.h>#if (UNIVERSAL_INTERFACES_VERSION >= 0x0330) /* 991206 MF/JW change to insure compilation w/3.3											    headers.											 */#include <ControlDefinitions.h>          #endif#include "strings.h"extern 	 _String 	statusLine, taskLine, timerLine;extern   long		barPercent;//#pragma bool on//#define TRUE true//#define FALSE false/*	The following are declared in unix.c in the ANSI libraries ...*/#ifdef __cplusplusextern "C" {#endif#if !__MSL__	extern char __system7present;	extern void __CheckForSystem7(void);#else	extern int __system7present(void);#endif /* ! __MSL__ */#ifdef __cplusplus}#endif/************************************************************************//* Purpose..: Check if the window belongs to us							*//* Input....: Pointer to the window										*//* Returns..: TRUE ours                    								*//************************************************************************/static void FlashControl(ControlHandle theControl){	unsigned long aLong;	HiliteControl(theControl, 1);	Delay(3L, &aLong);	HiliteControl(theControl, 0);}/************************************************************************//* Purpose..: Frame a control											*//* Input....: Control Handle											*//* Returns..: ---                    									*//************************************************************************/static void FrameControl(ControlHandle theControl){	Rect myRect;		HLock((Handle)theControl);	myRect.top = (*theControl)->contrlRect.top - 4;	myRect.left = (*theControl)->contrlRect.left - 4;	myRect.bottom = (*theControl)->contrlRect.bottom + 4;	myRect.right = (*theControl)->contrlRect.right + 4;	HUnlock((Handle)theControl);		PenNormal();	PenSize(3,3);	FrameRoundRect(&myRect,16,16);	PenNormal();}/************************************************************************//* Purpose..: Check if the window belongs to us							*//* Input....: Pointer to the window										*//* Returns..: TRUE ours                    								*//************************************************************************/Boolean SIOUXIsAppWindow(WindowPtr window){	return ((window == (WindowPtr)SIOUXTextWindow) || FALSE /* check for graphics */);}/************************************************************************//* Purpose..: Handles vertical scrolling		 						*//* Input....: Handle to the control										*//* Input....: part selected												*//* Returns..: ---                        								*//************************************************************************/void AdjustText(void)/*  this function was originally defined as static void AdjustText( void )  it was changed to allow access from SIOUX.c and enable Home, End, PageUp  and PageDown key operation. Something to be aware of in case it breaks  in the future.  --pcg*/{	/*	Since we can only do an adjust text on the textWindow ...*/#if SIOUX_USE_WASTE	WEReference theTE = SIOUXTextWindow->edit;	long change;	LongRect weViewRect, weDestRect;		WEGetViewRect( &weViewRect, theTE );	WEGetDestRect( &weDestRect, theTE );		change = weViewRect.top -			 weDestRect.top -			 LCGetValue(SIOUXTextWindow->vscroll) *				/*¥¥¥LC */			 WEGetHeight( 0, 1, SIOUXTextWindow->edit );		if (change != 0) {		WEScroll(0, change, theTE);	}#else	TEHandle theTE = SIOUXTextWindow->edit;	short change;		change = (*theTE)->viewRect.top -			 (*theTE)->destRect.top -			 GetControlValue(SIOUXTextWindow->vscroll) *			 (*theTE)->lineHeight;	if (change != 0) {		TEScroll(0, change, theTE);	}#endif /* SIOUX_USE_WASTE */}/************************************************************************//* Purpose..: Handles vertical scrolling 								*//* Input....: Handle to the control										*//* Input....: part selected												*//* Returns..: ---                        								*//************************************************************************/void SetTextView(pSIOUXWin theWindow){#if SIOUX_USE_WASTE	WEReference theTE = theWindow->edit;	WindowPtr theWP = (WindowPtr)theWindow;		LongRect weViewRect, weDestRect;	Rect tempRect;	tempRect = theWP->portRect;	WERectToLongRect( &tempRect, &weViewRect );	/*	Adjust for the scrollbars ...*/	weViewRect.right -= 16;	/*	Adjust for the status line ...*/	if (SIOUXSettings.showstatusline)		weViewRect.bottom -= 15;		WELongRectToRect( &weViewRect, &tempRect );	InsetRect(&tempRect, 4, 4);	WERectToLongRect( &tempRect, &weViewRect );		theWindow->linesInFolder = (weViewRect.bottom - weViewRect.top) /								WEGetHeight( 0, 1, theTE );	weViewRect.bottom = weViewRect.top +								(WEGetHeight( 0, 1, theTE ) * theWindow->linesInFolder);		WESetViewRect( &weViewRect, theTE );	WEGetDestRect( &weDestRect, theTE );	weDestRect.right = weViewRect.right;	WESetDestRect( &weViewRect, theTE );		WECalText(theTE);#else	TEHandle theTE = theWindow->edit;	WindowPtr theWP = (WindowPtr)theWindow;		Rect tempRect;	(*theTE)->viewRect = theWP->portRect;	tempRect = theWP->portRect;	/*	Adjust for the scrollbars ...*/	(*theTE)->viewRect.right -= 16;	/*	Adjust for the status line ...*/	if (SIOUXSettings.showstatusline)		(*theTE)->viewRect.bottom -= 15;		InsetRect(&(*theTE)->viewRect, 4, 4);		theWindow->linesInFolder = ((*theTE)->viewRect.bottom - (*theTE)->viewRect.top) /								(*theTE)->lineHeight;		(*theTE)->viewRect.bottom = (*theTE)->viewRect.top +								((*theTE)->lineHeight * theWindow->linesInFolder);		(*theTE)->destRect.right = (*theTE)->viewRect.right;		TECalText(theTE);#endif /* SIOUX_USE_WASTE */}/************************************************************************//* Purpose..: Draw the framing lines ...		  						*//* Input....: Pointer to the window	    								*//* Returns..: ---                        								*//************************************************************************/void SIOUXDrawGrowBox(WindowPtr theWindow){	Rect aRect;	short width, height;	GrafPtr savePort;	GetPort(&savePort);	SetPort(theWindow);	width = theWindow->portRect.right - theWindow->portRect.left;	height = theWindow->portRect.bottom - theWindow->portRect.top;	    SetRect(&aRect, width - 15, -1, width, height);    ClipRect(&aRect);    DrawGrowIcon(theWindow);    ClipRect(&SIOUXBigRect);	SetPort(savePort);}				/************************************************************************//* Purpose..: Update the window ...  									*//* Input....: Pointer to the Window										*//* Returns..: ---                        								*//************************************************************************/void SIOUXUpdateWindow(WindowPtr theWindow){	GrafPtr savePort;		GetPort(&savePort);	SetPort(theWindow);	BeginUpdate(theWindow);	EraseRect(&theWindow->portRect);	if (theWindow == (WindowPtr)SIOUXTextWindow) {		DrawControls(theWindow);		SIOUXDrawGrowBox(theWindow);		SIOUXUpdateStatusLine(theWindow);		#if SIOUX_USE_WASTE		WEUpdate(nil, ((pSIOUXWin)theWindow)->edit);#else		TEUpdate(&theWindow->portRect,				 ((pSIOUXWin)theWindow)->edit);#endif /* SIOUX_USE_WASTE */		}	EndUpdate(theWindow);	SetPort(savePort);}/************************************************************************//* Purpose..: Update the Scrollbar's state		 						*//* Input....: ---														*//* Returns..: ---                        								*//************************************************************************/void SIOUXUpdateScrollbar(void){#if SIOUX_USE_WASTE	long topLineNumber;	long lines;	long height;	WEReference theTE = SIOUXTextWindow->edit;		LongRect weViewRect, weDestRect;	WEGetViewRect( &weViewRect, theTE );	WEGetDestRect( &weDestRect, theTE );		height = WEGetHeight( 0, 1, theTE );	topLineNumber = (weViewRect.top - weDestRect.top) /					WEGetHeight( 0, 1, theTE );		lines = WECountLines( theTE ) - SIOUXTextWindow->linesInFolder;	/*	Following is to correct a bug in TextEdit where if the last char*/	/*	is an eol the line count will be wrong ...*/	/* Apparently, this is needed for WASTE as well.  -pcg */	if ((WEGetTextLength( theTE ) > 0) &&		( WEGetChar( WEGetTextLength( theTE ) - 1, theTE ) == 0x0d ))	{		lines++;	}#else	short topLineNumber;	short lines;	TEHandle theTE = SIOUXTextWindow->edit;		topLineNumber = ((*theTE)->viewRect.top - (*theTE)->destRect.top) /					((*theTE)->lineHeight);		lines = (*theTE)->nLines - SIOUXTextWindow->linesInFolder;	/*	Following is to correct a bug in TextEdit where if the last char*/	/*	is an eol the line count will be wrong ...*/	if (((*theTE)->teLength > 0) &&		((*(*theTE)->hText)[(*theTE)->teLength - 1] == 0x0d))	{		lines++;	}#endif /* SIOUX_USE_WASTE */	if (lines < 0) {		lines = 0;	}#if SIOUX_USE_WASTE	LCSetMax(SIOUXTextWindow->vscroll, lines);		/* ¥¥¥LC */	LCSetValue(SIOUXTextWindow->vscroll, topLineNumber);#else	SetControlMaximum(SIOUXTextWindow->vscroll, lines);	SetControlValue(SIOUXTextWindow->vscroll, topLineNumber);#endif /* SIOUX_USE_WASTE */}/************************************************************************//* Purpose..: Handles vertical scrolling		 						*//* Input....: Handle to the control										*//* Input....: Distance to scroll										*//* Returns..: ---                        								*//************************************************************************/#if SIOUX_USE_WASTE	void MoveScrollBox(ControlHandle theControl, long scrollDistance)#else	void MoveScrollBox(ControlHandle theControl, short scrollDistance)#endif /* SIOUX_USE_WASTE *//*  this function was originally defined as static void MoveScrollBox( void )  it was changed to allow access from SIOUX.c and enable Home, End, PageUp  and PageDown key operation. Something to be aware of in case it breaks  in the future.  --pcg*/{#if SIOUX_USE_WASTE	long oldSetting = LCGetValue(theControl);		/*¥¥¥LC */	long maxValue = LCGetMax(theControl);	long setting;#else	short oldSetting = GetControlValue(theControl);	short maxValue = GetControlMaximum(theControl);	short setting;#endif /* SIOUX_USE_WASTE */		setting = oldSetting - scrollDistance;	if (setting < 0) {		setting = 0;	} else {		if (setting > maxValue) {			setting = maxValue;		}	}#if SIOUX_USE_WASTE									/*¥¥¥LC */	LCSetValue(theControl, setting);#else	SetControlValue(theControl, setting);#endif /* SIOUX_USE_WASTE */}/************************************************************************//* Purpose..: Draws SIOUX's status line			 						*//* Input....: Pointer to the window										*//* Returns..: ---                        								*//************************************************************************/void SIOUXUpdateStatusLine(WindowPtr theWindow){	GrafPtr saveport;	Rect box, box2, box3;	static	PixPatHandle	blueFill = GetPixPat(132), barFill = GetPixPat(133), whiteFill = GetPixPat(128);	static char *state = "File";	static char *task = "Status";	static char *printfing = "handling output";	static char *scanfing = "handling input";		GWorldPtr   offScreenMap = nil;//	GDHandle    offGD;	#if SIOUX_USE_WASTE	SInt32 lineHeight = WEGetHeight( 0, 1, SIOUXTextWindow->edit );#else	short lineHeight = (*SIOUXTextWindow->edit)->lineHeight;#endif /* SIOUX_USE_WASTE */	if (!SIOUXSettings.showstatusline)		return;			GetPort(&saveport);	theWindow = (WindowPtr)SIOUXTextWindow;//	SetPort(theWindow);	SetRect(&box,0,theWindow->portRect.bottom-15,theWindow->portRect.right - 15,theWindow->portRect.bottom);	if (NewGWorld(&offScreenMap,0,&box,0,GetMainDevice(),noNewDevice)!=noErr)		return;	box3 = box;	SetPort ((GrafPort*)offScreenMap);		box.top = 0;	box.bottom = 15;		box2 = box;	InsetRect(&box, -1, -1);//	ClipRect(&box);	InsetRect(&box, 1, 1);	box.right = 30;	FillCRect (&box, blueFill);	box.left = 30;	box.right = box2.right;	EraseRect(&box);		TextMode (srcBic);	TextFont(kFontIDGeneva );	TextSize(9);	TextFace(bold);	/*	Draw SIOUX State: */	MoveTo(4, box.bottom - 3);	DrawText(state,0,strlen(state));	/*	Draw state ... */	MoveTo(32, box.bottom - 3);	TextMode (srcOr);	TextFace(normal);	DrawText(statusLine.getStr(),0,statusLine.sLength);	box.left = 150;	box.right = 190;	FillCRect (&box, blueFill);	TextMode (srcBic);	TextFace(bold);	MoveTo(152, box.bottom-3);	DrawText(task,0,strlen(task));	box.left = 190;	TextMode (srcOr);	TextFace(normal);	MoveTo(192, box.bottom-3);	switch(SIOUXState) {		case PRINTFING:			DrawText(printfing,0,strlen(printfing));			break;		case SCANFING:			DrawText(scanfing,0,strlen(scanfing));			break;		default:			DrawText(taskLine.getStr(),0,taskLine.sLength);	}		box.right = box2.right;	box.left = box.right - 50;	FillCRect (&box, blueFill);	TextMode (srcBic);	MoveTo(box.left+2, box.bottom-3);	DrawText(timerLine.getStr(),0,timerLine.sLength);		if (barPercent >= 0)	{		TextMode (srcOr);		box.right = box.left-5;		box.left-=75;		box.top+=3;		box.bottom-=2;		FillCRect (&box,whiteFill);		box.right = box.left+(box.right-box.left)*barPercent/100;		FillCRect (&box,barFill);		box.right = box.left+70;		FrameRect (&box);		TextFont(kFontIDTimes );		MoveTo(box.left+28, box.bottom-2);		_String pLine (barPercent);		pLine = pLine & "%";		DrawText(pLine.getStr(),0,pLine.sLength);	}	MoveTo(0, 0);	Line(theWindow->portRect.right - 15, 0);   // SetPort(theWindow);	SetPort((WindowPtr)SIOUXTextWindow);    CopyBits (&(GrafPtr(offScreenMap)->portBits),&(theWindow->portBits), &box2, &box3, srcCopy,nil);    DisposeGWorld (offScreenMap);    SetPort(saveport);}/************************************************************************//* Purpose..: Grow the window (doesn't draw the bottom line)			*//* Input....: Pointer to window to grow                     			*//* Input....: Initial mouse point										*//* Returns..: ---														*//************************************************************************/void SIOUXMyGrowWindow(WindowPtr theWindow, Point thePoint){	GrafPtr savePort;	Rect scrollRect;	long result;#if SIOUX_USE_WASTE	SInt32 lineHeight = WEGetHeight( 0, 1, SIOUXTextWindow->edit );	long cntlheight;#else	short lineHeight = (*SIOUXTextWindow->edit)->lineHeight;	short cntlheight;#endif /* SIOUX_USE_WASTE */	GetPort(&savePort);	SetPort(theWindow);		result = GrowWindow(theWindow, thePoint, &SIOUXDragRect);	if (result == 0)		return;	EraseRect(&theWindow->portRect);	SizeWindow(theWindow,			   (((LoWord(result) - 24) / CharWidth('0')) * CharWidth('0')) + 24,			   (((HiWord(result) - 8) / lineHeight) * lineHeight) + 8,			   false);	InvalRect(&theWindow->portRect);	SetTextView((pSIOUXWin)theWindow);	cntlheight = theWindow->portRect.top - 1;	//if (SIOUXSettings.showstatusline)	//	cntlheight += lineHeight + 4;	MoveControl(((pSIOUXWin)theWindow)->vscroll,			theWindow->portRect.right - 15,			cntlheight);		/*	16 pixels wide and top - bottom of screen plus 1 at both ends ...*/	cntlheight = theWindow->portRect.bottom - theWindow->portRect.top - 13;//	if (SIOUXSettings.showstatusline)//		cntlheight -= 1;	SizeControl(((pSIOUXWin)theWindow)->vscroll, 16, cntlheight);	scrollRect = (*((pSIOUXWin)theWindow)->vscroll)->contrlRect;	ValidRect(&scrollRect);		SIOUXUpdateScrollbar();	AdjustText();		SetPort(savePort);}/************************************************************************//* Purpose..: Handles vertical scrolling 								*//* Input....: Handle to the control										*//* Input....: part selected												*//* Returns..: ---                        								*//************************************************************************/static pascal void VActionProc(ControlHandle theControl, short part){	/*	Since the graphics window will not have a scrollbar,*/	/*	then we can assume that if we are in	this procedure the frontwindow*/	/*	is the textWindow ...*/#if SIOUX_USE_WASTE	WEReference theTE = SIOUXTextWindow->edit;	long scrollAdjust;	LongRect weViewRect;#else	TEHandle theTE = SIOUXTextWindow->edit;	short scrollAdjust;#endif /* SIOUX_USE_WASTE */		if (part == 0) {		return;	}	switch (part) {		case kControlUpButtonPart:		case kControlDownButtonPart:			scrollAdjust = 1;			break;		case kControlPageUpPart:		case kControlPageDownPart:#if SIOUX_USE_WASTE			WEGetViewRect( &weViewRect, theTE );			scrollAdjust = (weViewRect.bottom - weViewRect.top) /			   		 	   WEGetHeight( 0, 1, theTE );#else			scrollAdjust = ((*theTE)->viewRect.bottom - (*theTE)->viewRect.top) /			   		 	   ((*theTE)->lineHeight);#endif /* SIOUX_USE_WASTE */			break;	}	if ((part == kControlDownButtonPart) || (part == kControlPageDownPart)) {	//if ((part == kControlUpButtonPart) || (part == kControlPageUpPart)) {		scrollAdjust = -scrollAdjust;	}	MoveScrollBox(theControl, scrollAdjust);	AdjustText();}/************************************************************************//* Purpose..: Handles a click in the content region of a window 		*//* Input....: The window clicked in ...									*//* Input....: The event which occurred ...								*//* Returns..: ---                        								*//************************************************************************/void SIOUXDoContentClick(WindowPtr window, EventRecord *theEvent){	short part;	ControlHandle theControl;	GrafPtr savePort;#if SIOUX_USE_WASTE	LongRect weViewRect;	Rect tempRect;	SInt32 weSelStart, weSelEnd;#endif /* SIOUX_USE_WASTE */		GetPort(&savePort);	SetPort(window);	GlobalToLocal(&theEvent->where);	if ((part = FindControl(theEvent->where, window, &theControl)) == 0) {	#if SIOUX_USE_WASTE		/*	Check to see if the user clicked in the textWindow ...*/		WEGetViewRect( &weViewRect, SIOUXTextWindow->edit );		WELongRectToRect( &weViewRect, &tempRect );		if (PtInRect(theEvent->where, &tempRect)) {			WEClick(theEvent->where,					theEvent->modifiers,					theEvent->when,					SIOUXTextWindow->edit);			WEGetSelection( &weSelStart, &weSelEnd, SIOUXTextWindow->edit );			if ( ( weSelStart == weSelEnd) &&				!SIOUXisinrange(SIOUXselstart, SIOUXTextWindow->edit))			{				WESetSelection(SIOUXselstart, SIOUXselstart, SIOUXTextWindow->edit);			}#else		/*	Check to see if the user clicked in the textWindow ...*/		if (PtInRect(theEvent->where, &((*SIOUXTextWindow->edit)->viewRect))) {			TEClick(theEvent->where,					(theEvent->modifiers & shiftKey) != 0,					SIOUXTextWindow->edit);			if (((*SIOUXTextWindow->edit)->selStart == (*SIOUXTextWindow->edit)->selEnd) &&				!SIOUXisinrange(SIOUXselstart, SIOUXTextWindow->edit))			{				TESetSelect(SIOUXselstart, SIOUXselstart, SIOUXTextWindow->edit);			}#endif /* SIOUX_USE_WASTE */						SIOUXUpdateScrollbar();		}	} else if (part == kControlIndicatorPart) {		TrackControl(theControl, theEvent->where, 0L);#if SIOUX_USE_WASTE		/* ¥¥¥LC */		LCSynch(theControl);#endif /* SIOUX_USE_WASTE */		AdjustText();	} else {		ControlActionUPP tempUPP;				tempUPP = NewControlActionProc(VActionProc);		TrackControl(theControl, theEvent->where, tempUPP);		DisposeRoutineDescriptor(tempUPP);	}	SetPort(savePort);}#if SIOUX_USE_WASTEstatic pascal void ScrollProc ( WEReference /*edit*/ ){	SIOUXUpdateScrollbar ( ) ;}#endif/************************************************************************//* Purpose..: Initialize the SIOUX textWindow							*//* Input....: Number of columns											*//* Input....: Number of rows											*//* Returns..: TRUE the window was initialized							*//************************************************************************/Boolean SIOUXSetupTextWindow(void){	Rect aRect = {0,0,1,1};	FontInfo fi;	#if SIOUX_USE_WASTE	static WEScrollUPP scrollProc = nil ;	LongRect tempLongRect;	long lineHeight, screenHeight, screenWidth;	UInt32 weFeatures;/*SInt32 response; */	/* ¥¥¥MP */#else	short lineHeight, screenHeight, screenWidth;#endif /* SIOUX_USE_WASTE */		ProcessSerialNumber psn;	ProcessInfoRec pinfo;	OSErr err;	Str63	AppName;	GrafPtr saveport;	/*	Get process Info*/	GetPort(&saveport);#if ! __MSL__	if (__system7present == -1)		__CheckForSystem7();	if (__system7present)#else	if (__system7present())#endif /* __MSL__ */	{		err = GetCurrentProcess(&psn);		pinfo.processName = AppName;		pinfo.processInfoLength = sizeof(pinfo);		pinfo.processAppSpec = NULL;		err = GetProcessInformation(&psn,&pinfo);		if (pinfo.processName[0] <= 59) {			pinfo.processName[++(pinfo.processName[0])] = '.';			pinfo.processName[++(pinfo.processName[0])] = 'o';			pinfo.processName[++(pinfo.processName[0])] = 'u';			pinfo.processName[++(pinfo.processName[0])] = 't';		}		if (SIOUXSettings.userwindowtitle != NULL)   /* mm 980609 */			BlockMoveData(SIOUXSettings.userwindowtitle, AppName, 											(long)SIOUXSettings.userwindowtitle[0]+1);	}	if (*AppName == 0)		BlockMoveData("\pSIOUX TextWindow", AppName, 17L);	/*	Initialize the TextWindPtr ...*/	SIOUXTextWindow = (pSIOUXWin)NewPtr(sizeof(tSIOUXWin));	if (SIOUXTextWindow == 0)		return FALSE;/*	SIOUXTextWindow = &SIOUXTextWindowBuf*/	if (!(SIOUXTextWindow->window = NewCWindow(NULL, &aRect, AppName, FALSE,				  documentProc, (WindowPtr) -1L, FALSE, 0L)))		return false;	SetPort((WindowPtr)SIOUXTextWindow);	/*	Set the font information ...*/	TextFont(SIOUXSettings.fontid);	TextSize(SIOUXSettings.fontsize);	TextFace(SIOUXSettings.fontface);	GetFontInfo(&fi);	lineHeight = fi.ascent + fi.descent + fi.leading;	/*	Size the window ...*/	SIOUXSettings.columns = (SIOUXSettings.columns <= 0) ? 80 : SIOUXSettings.columns;	SIOUXSettings.rows = (SIOUXSettings.rows <= 0) ? 24 : SIOUXSettings.rows;	if (SIOUXSettings.showstatusline)		aRect.bottom = 2*4 + (SIOUXSettings.rows )*lineHeight + 19;	/*	2*indent + ... + titlebar*/	else		aRect.bottom = 2*4 + (SIOUXSettings.rows)*lineHeight + 4;	/*	2*indent + ... + titlebar*/	aRect.right = 2*4 + SIOUXSettings.columns*CharWidth('0') + 16,	/*	2*indent + ... + scrollbar*/	screenHeight = qd.screenBits.bounds.bottom - qd.screenBits.bounds.top - LMGetMBarHeight() - 24;	/*	screen height ...*/	screenWidth = qd.screenBits.bounds.right - qd.screenBits.bounds.left;	if (aRect.bottom > screenHeight)		aRect.bottom = ((screenHeight - 2*4 - 4) / lineHeight) * lineHeight + 2*4 + 4;	/*	Move the window to the correct place ...*/	if (SIOUXSettings.toppixel == 0 && SIOUXSettings.leftpixel == 0) {		if (aRect.right > screenWidth) /*	The window is wider than the screen*/			aRect.right = ((screenWidth - 2*4 - 16 - 20) / CharWidth('0')) * CharWidth('0') + 2*4 + 16;		MoveWindow ((WindowPtr)SIOUXTextWindow,					((qd.screenBits.bounds.right - qd.screenBits.bounds.left - aRect.right) / 2),					((screenHeight - aRect.bottom) / 5 + LMGetMBarHeight() + 24),					FALSE);	} else		MoveWindow ((WindowPtr)SIOUXTextWindow,					SIOUXSettings.leftpixel, SIOUXSettings.toppixel,					FALSE);	/*	Now make it the correct size ...*/	SizeWindow((WindowPtr)SIOUXTextWindow, aRect.right, aRect.bottom, TRUE);	/*	Create the vertical scrollbar ...*/	aRect = ((WindowPtr)SIOUXTextWindow)->portRect;	aRect.left = aRect.right - 15;	aRect.right += 1;	aRect.bottom -= 14;	aRect.top -= 1;//	if (SIOUXSettings.showstatusline)		//aRect.bottom -= 1;			/*	factor in the status window ...*/	SIOUXTextWindow->vscroll = NewControl((WindowPtr)SIOUXTextWindow, &aRect, "\p",									 TRUE, 0, 0, 0, scrollBarProc, 0L);#if SIOUX_USE_WASTE		/* ¥¥¥LC */	/*	Attach a LongControls record to the scrollbar */	err = LCAttach(SIOUXTextWindow->vscroll);	/* what do I do with the error code? */#endif	ShowWindow((WindowPtr)SIOUXTextWindow);	/*	Create the TEHandle ...*/	aRect = qd.thePort->portRect;	aRect.right -= 15;	if (SIOUXSettings.showstatusline)		aRect.bottom -= 15;	InsetRect(&aRect, 4, 4);#if SIOUX_USE_WASTE	WERectToLongRect( &aRect, &tempLongRect );	weFeatures = ( weDoAutoScroll | weDoDrawOffscreen | weDoMonoStyled );	if ( SIOUXSettings.wasteusetempmemory )		weFeatures |= weDoUseTempMem;	if ( SIOUXSettings.enabledraganddrop )		weFeatures |= ( weDoDragAndDrop | weDoOutlineHilite );	if ( SIOUXSettings.outlinehilite )		weFeatures |= weDoOutlineHilite;	err = WENew(&tempLongRect, &tempLongRect, weFeatures, &SIOUXTextWindow->edit);		/*	install the scroll callback */	if ( scrollProc == nil )	{		scrollProc = NewWEScrollProc( ScrollProc );	}	err = WESetInfo( weScrollProc, & scrollProc, SIOUXTextWindow->edit );#else	SIOUXTextWindow->edit = TEStyleNew(&aRect, &aRect);	FontInfo	FI;	GetFontInfo (&FI);	(*(SIOUXTextWindow->edit))->lineHeight = FI.leading+FI.ascent+FI.descent;	(*(SIOUXTextWindow->edit))->fontAscent = FI.ascent;		TEAutoView(TRUE, SIOUXTextWindow->edit);#endif /* SIOUX_USE_WASTE */		SIOUXTextWindow->linesInFolder = SIOUXSettings.rows;	/*	Number of lines visible ...*/	SIOUXTextWindow->dirty = 0;								/*	Window is clean ...*/	SIOUXTextWindow->dirid = 0;								/*	Window hasn't been saved yet ...*/	SIOUXUpdateWindow((WindowPtr)SIOUXTextWindow);	SetPort(saveport);	return(TRUE);}/****************************************************************//* Purpose..: Display a simple aboutbox  						*//* Input....: ---												*//* Returns..: ---												*//****************************************************************/void SIOUXDoAboutBox(void){	WindowPtr wp;	GrafPtr savePort;	EventRecord theEvent;#if SIOUX_USE_WASTE	Rect aRect = {0, 0,196, 300};#else	Rect aRect = {0, 0,125, 240};#endif /* SIOUX_USE_WASTE */	RGBColor aRed = {65535, 0, 0};	RGBColor aBlack = {0, 0, 0};	short height, width;	SetCursor(&qd.arrow);	GetPort(&savePort);		/* Center it horizontally and 20% down vertically */	width = (qd.screenBits.bounds.right - qd.screenBits.bounds.left - aRect.right) / 2;	height = (qd.screenBits.bounds.bottom - qd.screenBits.bounds.top - LMGetMBarHeight() - aRect.bottom) / 5 + LMGetMBarHeight();			OffsetRect(&aRect, width, height);		/* Create a simple window without button ... */	if ((wp = NewWindow(0L, &aRect, "\p", TRUE, dBoxProc, (WindowPtr)-1L, FALSE, 0L)) == 0L) {		SysBeep(1);		return;	}		SetPort(wp);	TextFont(0);	/* Draw the text into the window ... */	TextSize(36);	TextFace(bold);	RGBForeColor(&aRed);	#if SIOUX_USE_WASTE	SetRect(&aRect, 0, 5, 300, 55);	TETextBox("SIOUX-WASTE", 11, &aRect, teCenter);	TextSize(12);	TextFace(0);	RGBForeColor(&aBlack);	SetRect(&aRect, 0, 55, 300, 75);	TETextBox("Simple Input/Output User eXchange", 33, &aRect, teCenter);		SetRect(&aRect, 0, 75, 300, 92);	TETextBox("By: Berardino E. Baratta", 24, &aRect, teCenter);	SetRect(&aRect, 0, 92, 300, 112);	TETextBox("©Metrowerks Inc. 1993-1997", 26, &aRect, teCenter);		SetRect(&aRect, 0, 112, 300, 129);	TETextBox("using the WASTE text engine", 27, &aRect, teCenter);	SetRect(&aRect, 0, 129, 300, 149);	TETextBox("©Marco Piovanelli 1993-1997", 27, &aRect, teCenter);		SetRect(&aRect, 0, 149, 300, 166);	TETextBox("TextEdit-to-WASTE conversion", 28, &aRect, teCenter);	SetRect(&aRect, 0, 166, 300, 186);	TETextBox("©Paul Goracke 1997", 18, &aRect, teCenter);#else	SetRect(&aRect, 0, 5, 240, 55);	TETextBox("SIOUX", 5, &aRect, teCenter);	TextSize(12);	TextFace(0);	RGBForeColor(&aBlack);	SetRect(&aRect, 0, 55, 240, 75);	TETextBox("Simple Input/Output User eXchange", 33, &aRect, teCenter);	SetRect(&aRect, 0, 75, 240, 95);	TETextBox("By: Berardino E. Baratta", 24, &aRect, teCenter);	SetRect(&aRect, 0, 95, 240, 115);	TETextBox("©Metrowerks Inc. 1993-1997", 26, &aRect, teCenter);#endif /* SIOUX_USE_WASTE */	while (!GetNextEvent(mDownMask | keyDownMask, &theEvent))		/* just loop */ ;		DisposeWindow(wp);	SetPort(savePort);}/****************************************************************//* Purpose..: Display an alert style window  					*//* Input....: Do we initialize the toolbox                      *//* Input....: The window's rectangle                       		*//* Returns..: TRUE the window was opened                        *//****************************************************************/void SIOUXCantSaveAlert(Str63 filename){	WindowPtr wp, theWindow;	GrafPtr savePort;	EventRecord theEvent;	Handle theIcon;	ControlHandle okButton, dummyCntl;	Rect aRect = {0, 0, 75, 270};	Boolean done = FALSE;	char aString[100] = "An error occurred while saving '";	short length;	short height, width;	SetCursor(&qd.arrow);	GetPort(&savePort);		/*	Center it horizontally and 20% down vertically*/	width = (qd.screenBits.bounds.right - qd.screenBits.bounds.left - aRect.right) / 2;	height = (qd.screenBits.bounds.bottom - qd.screenBits.bounds.top - LMGetMBarHeight() - aRect.bottom) / 5 + LMGetMBarHeight();		OffsetRect(&aRect, width, height);		/*	Create a simple window with an OK button*/	if ((wp = NewWindow(0L, &aRect, "\p", TRUE, dBoxProc,						(WindowPtr)-1L, FALSE, 0L)) == 0L)	{		SysBeep(10);		return;	}	SetPort(wp);	TextFont(0);	TextSize(12);	TextFace(0);	SetRect(&aRect, 50, 4, 260, 46);	length = strlen(aString);	BlockMoveData(&filename[1], &aString[length], filename[0]);	aString[length + filename[0] + 1] = '\0';	strcat(aString, "'.");	TETextBox(aString, strlen(aString), &aRect, teForceLeft);	SetRect(&aRect, 8, 8, 40, 40);	theIcon = GetIcon(0);	PlotIcon(&aRect, theIcon);	SetRect(&aRect, 105, 50, 165, 68);	okButton = NewControl(wp, &aRect, "\pOK", TRUE, 0, 0, 0, pushButProc|kControlUsesOwningWindowsFontVariant, 0);	/*	Outline the default button ...*/	FrameControl(okButton);		while (!done) {		if(GetNextEvent(mDownMask | keyDownMask, &theEvent)) {			if (theEvent.what == mouseDown) {				if ((FindWindow(theEvent.where, &theWindow) == inContent) && (theWindow == wp)) {					GlobalToLocal(&theEvent.where);					if (FindControl(theEvent.where, wp, &dummyCntl) == kControlButtonPart)						if (TrackControl(dummyCntl, theEvent.where, 0L) != 0) {							done = TRUE;						}				}			} else if (theEvent.what == keyDown) {				char key;								key = theEvent.message & charCodeMask;				if (key == 0x0d || key == 0x03) {					FlashControl(okButton);					done = TRUE;				}			}		}	}		DisposeControl(okButton);	DisposeWindow(wp);	/* ReleaseResource(theIcon);*/             /* mm 980415 */	SetPort(savePort);}/****************************************************************//* Purpose..: Ask the user if he/she wishes to save				*//* Input....: The name of the file                       		*//* Returns..: Yes, No, Cancel			                        *//****************************************************************/short SIOUXYesNoCancelAlert(Str63 filename){	WindowPtr wp, theWindow;	GrafPtr savePort;	EventRecord theEvent;	Handle theIcon;	short item;	ControlHandle yesButton, noButton, cancelButton, dummyCntl;	Rect aRect = {0, 0, 89, 386};	char aString[110] = "Do you wish to save '";	Boolean done = FALSE;	short length;	short height, width;	SetCursor(&qd.arrow);	GetPort(&savePort);		/*	Center it horizontally and 20% down vertically*/	width = (qd.screenBits.bounds.right - qd.screenBits.bounds.left - aRect.right) / 2;	height = (qd.screenBits.bounds.bottom - qd.screenBits.bounds.top - LMGetMBarHeight() - aRect.bottom) / 5 + LMGetMBarHeight();		OffsetRect(&aRect, width, height);		/*	Create a simple window without button ...*/	if ((wp = NewWindow(0L, &aRect, "\p", TRUE, dBoxProc,						(WindowPtr)-1L, FALSE, 0L)) == 0L)	{		SysBeep(10);		return (-1);	}	SetPort(wp);	/*	Draw the text box ...*/	TextFont(0);	TextSize(12);	TextFace(0);	SetRect(&aRect, 78, 12, 373, 44);	length = strlen(aString);	BlockMoveData(&filename[1], &aString[length], filename[0]);	aString[length + filename[0] + 1] = '\0';	strcat(aString, "' before quitting?");	TETextBox(aString, strlen(aString), &aRect, teForceLeft);	/*	Draw the icon*/	SetRect(&aRect, 23, 12, 55, 44);	theIcon = GetIcon(2);	PlotIcon(&aRect, theIcon);	if (SIOUXSettings.standalone) {		/*	Draw the Don't Save button ...*/		SetRect(&aRect, 78, 57, 158, 77);		noButton = NewControl(wp, &aRect, "\pDon't Save", TRUE, 0, 0, 0, pushButProc|kControlUsesOwningWindowsFontVariant, 0);		/*	Draw the Cancel button ...*/		SetRect(&aRect, 245, 57, 304, 77);		cancelButton = NewControl(wp, &aRect, "\pCancel", TRUE, 0, 0, 0, pushButProc|kControlUsesOwningWindowsFontVariant, 0);	} else {		/*	Draw the Don't Save button ...*/		SetRect(&aRect, 224, 57, 304, 77);		noButton = NewControl(wp, &aRect, "\pDon't Save", TRUE, 0, 0, 0, pushButProc|kControlUsesOwningWindowsFontVariant, 0);	}	/*	Draw the Save button ...*/	SetRect(&aRect, 314, 57, 374, 77);	yesButton = NewControl(wp, &aRect, "\pSave", TRUE, 0, 0, 0, pushButProc|kControlUsesOwningWindowsFontVariant, 0);	/*	Outline the default button ...*/	FrameControl(noButton);	while (!done) {		if(GetNextEvent(mDownMask | keyDownMask, &theEvent)) {			if (theEvent.what == mouseDown) {				if ((FindWindow(theEvent.where, &theWindow) == inContent) && (theWindow == wp)) {					GlobalToLocal(&theEvent.where);					if (FindControl(theEvent.where, wp, &dummyCntl) == kControlButtonPart)						if (TrackControl(dummyCntl, theEvent.where, 0L) != 0) {							if (dummyCntl == yesButton)								item = 1;							if (dummyCntl == noButton)								item = 2;							if (SIOUXSettings.standalone && dummyCntl == cancelButton)								item = 3;							done = TRUE;						}				}			} else if (theEvent.what == keyDown) {				char key;								key = theEvent.message & charCodeMask;				if (key == 'Y' || key == 'y' || key == 'S' || key == 's') {					item = 1;					FlashControl(yesButton);					done = TRUE;				} else if (key == 'N' || key == 'n' ||						   key == 'D' || key == 'd' ||						   key == 0x0d || key == 0x03) {					/*	CR or ENTER key go here*/					item = 2;					FlashControl(noButton);					done = TRUE;				} else if (SIOUXSettings.standalone) {					if ((key == '.' && (theEvent.modifiers & cmdKey)) || (key == 0x1b)) {						/*	ESCAPE key or command - . go here*/						item = 3;						FlashControl(cancelButton);						done = TRUE;					}				}			}		}	}		DisposeControl(yesButton);	DisposeControl(noButton);	if (SIOUXSettings.standalone)		DisposeControl(cancelButton);	DisposeWindow(wp);	/* ReleaseResource(theIcon); */          /* mm 980415 */	SetPort(savePort);	return (item);}#pragma bool reset/*  Change Record//	BB 04/10/93	Removed all calls to c2pstr and p2cstr so that we no//				longer need to import MacOS.lib//	BB 21/01/94	Added SIOUXDrawGrowBox to handle custom grow icon//	BB 21/01/94	Also expanded the text area to use the larger terect//	BB 04/03/94	Changed the default button in the "do you want to save"//				Dialog from Yes to No, also made the dialog a little larger.//  JH 30/12/95 Removed uses of OLDROUTINENAMES. Added #include <Icons.h>//  bk 960902   need to add the following headers to free from ansiprefix.h//  mm 971006   Added #include of Sound.h because of change in universal headers//  mm 980415   Removed two ReleaseResource statements that released a shared resource MW00225//  mm 980609   Changes that allow user to specify window title before the SIOUX window is created.//*/