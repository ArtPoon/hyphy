/*	Menu/Button specific object for MacOS.		Sergei L. Kosakovsky Pond, May 2000.*/#include "HYPullDown.h"#include "HYLabel.h"#include "HYButtonBar.h"#include "HYPlatformButtonMenu.h"#include "HYPlatformWindow.h"#include "HYEventTypes.h"#include "HYList.h"#include "HYTableComponent.h"#include "errorfns.h"#include "ToolUtils.h"#include "Fonts.h"#include "HYUtils.h"#include "HYButton.h"#include "HYTextBox.h"#include "string.h"#include <ControlDefinitions.h>#include <Appearance.h>#include <Collections.h>		long	menuIDCounter = 20000;extern  bool 	forceUpdateForScrolling;Rect	HYRect2Rect (_HYRect&);#if TARGET_API_MAC_CARBON	#include <PMApplication.h>	extern PMPageFormat 	gPageFormat;	extern PMPrintSettings  gPrintSettings;	extern Handle 			gFlattenedFormat;	extern Handle 			gFlattenedSettings;#else	#include <Printing.h>	extern THPrint prRecHdl;#endifextern	Boolean			 InitPrint (void);//__________________________________________________________________________________void			AlignRectangle (_HYRect& rel , Rect& target , unsigned char alFlags){	long 	 temp;	if (alFlags&HY_ALIGN_RIGHT)	{		temp = target.right-target.left;		target.right = rel.right;		target.left = target.right - temp;	}	else	 if (!(alFlags&HY_ALIGN_LEFT))	 {		temp = (rel.right-rel.left-target.right+target.left)/2;		target.left+=temp;	 	target.right+=temp;	 }	if (alFlags&HY_ALIGN_BOTTOM)	{		temp = target.bottom-target.top;		target.bottom = rel.bottom;		target.top = target.bottom - temp;	}	else	 if (!(alFlags&HY_ALIGN_TOP))	 {		temp = (rel.bottom-rel.top-target.bottom+target.top)/2;		target.top+=temp;	 	target.bottom+=temp;	 }}//__________________________________________________________________________________RGBColor			buttonBorder1 = {0,0,0},		buttonBorder2 = {0x3fff,0x3fff,0x3fff};		//___________________________________________________________________HYPlatformPullDown::_HYPlatformPullDown(void){	myID = menuIDCounter++;	myMenu = NewMenu(myID,"\p");	backFill = NewPixPat();	if ((!backFill)||(!myMenu))	{		warnError (-108);	}	InsertMenu (myMenu,hierMenu);	RGBColor  wht = {0xffff,0xffff,0xffff};	#ifdef TARGET_API_MAC_CARBON		EnableMenuItem (myMenu,0);	#else		EnableItem (myMenu,0);	#endif	MakeRGBPat (backFill,&wht);	selection = 0;	}		//___________________________________________________________________HYPlatformPullDown::~_HYPlatformPullDown(void){	if (myMenu)	{		DeleteMenu (myID);		DisposeMenu (myMenu);	}	if (backFill)	{		DisposePixPat (backFill);	}}//__________________________________________________________________void		_HYPlatformPullDown::_AddMenuItem  	(_String& newItem, long index){		if (!myMenu) return;		if (index<=0)		index = 10000;			if (!newItem.Equal(&menuSeparator))	{		Str255 menuText;		StringToStr255 (newItem,menuText);		InsertMenuItem (myMenu,menuText,index);	}	else		InsertMenuItem (myMenu,"\p(-",index);}//__________________________________________________________________void		_HYPlatformPullDown::_SetMenuItem  	(_String& newItem, long index){		if (!myMenu) return;	index++;	if (!newItem.Equal(&menuSeparator))	{		Str255 menuText;		StringToStr255 (newItem,menuText);		SetMenuItemText (myMenu,index,menuText);	}	else		SetMenuItemText (myMenu,index,"\p(-");}//__________________________________________________________________void		_HYPlatformPullDown::_MarkItem  	(long index, char mark){		if (!myMenu) return;		switch (mark)	{		case HY_PULLDOWN_CHECK_MARK: 			mark = checkMark;			break;					case HY_PULLDOWN_DIAMOND_MARK: 			mark = diamondMark;			break;		case HY_PULLDOWN_BULLET_MARK: 			mark = 0xA5;			break;					default:			mark = noMark;	}	SetItemMark (myMenu,index+1,mark);}//__________________________________________________________________char		_HYPlatformPullDown::_ItemMark  	(long index){		if (!myMenu) return 0;		short   mark;	GetItemMark (myMenu, index+1,&mark);		switch (mark)	{		case checkMark: 			return HY_PULLDOWN_CHECK_MARK;					case diamondMark: 			return HY_PULLDOWN_DIAMOND_MARK;		case 0xA5: 			return HY_PULLDOWN_BULLET_MARK;				}	return HY_PULLDOWN_NO_MARK;}//__________________________________________________________________void		_HYPlatformPullDown::_DeleteMenuItem  (long index){		if (!myMenu) return;	DeleteMenuItem (myMenu,index+1);}//__________________________________________________________________void		_HYPlatformPullDown::_SetBackColor (_HYColor& c){	RGBColor newBG;	newBG.red = c.R*256;	newBG.blue = c.B*256;	newBG.green = c.G*256;	MakeRGBPat (backFill,&newBG);}//__________________________________________________________________long		_HYPlatformPullDown::_GetSelection (void){	return selection;}//__________________________________________________________________void		_HYPlatformPullDown::_Duplicate (Ptr p){	_HYPullDown * theSource = (_HYPullDown*) p;	myMenu 					= theSource->myMenu;	myID 					= theSource->myID;	selection 				= theSource->selection;	backFill 				= theSource->backFill;	theSource->backFill 	= nil;	theSource->myMenu 		= nil;}//__________________________________________________________________void		_HYPlatformPullDown::_Update (Ptr p){	_Paint (p);}//__________________________________________________________________void		_HYPlatformPullDown::_SetDimensions (_HYRect r, _HYRect rel){	_HYPullDown* theParent = (_HYPullDown*) this;	theParent->_HYPlatformComponent::_SetDimensions (r,rel);	_SetVisibleSize (rel);}//__________________________________________________________________void		_HYPlatformPullDown::_SetVisibleSize (_HYRect rel){	_HYPullDown* theParent = (_HYPullDown*) this;	menuRect.left 	= rel.left+3;	menuRect.bottom = rel.bottom;	menuRect.right	= rel.right-3;	menuRect.top 	= rel.top;	if (myMenu)	{		CalcMenuSize (myMenu);		if (menuRect.bottom-menuRect.top>20)		{			menuRect.bottom = menuRect.top+20;		}		#ifdef OPAQUE_TOOLBOX_STRUCTS			if (menuRect.right-menuRect.left>GetMenuWidth (myMenu)+22)				menuRect.right = menuRect.left+GetMenuWidth (myMenu) +22;				#else			if (menuRect.right-menuRect.left>(*myMenu)->menuWidth+22)				menuRect.right = menuRect.left+(*myMenu)->menuWidth+22;		#endif	}	AlignRectangle (rel, menuRect, theParent->GetAlignFlags());}//__________________________________________________________________void		_HYPlatformPullDown::_EnableItem (long theItem, bool toggle){	if (myMenu)		if (toggle)			#ifdef TARGET_API_MAC_CARBON				EnableMenuItem (myMenu,theItem+1);			#else				EnableItem (myMenu,theItem+1);			#endif		else			#ifdef TARGET_API_MAC_CARBON				DisableMenuItem (myMenu,theItem+1);			#else				DisableItem (myMenu,theItem+1);			#endif}//__________________________________________________________________void		_HYPlatformPullDown::_Paint (Ptr p){	_HYPullDown * theParent = (_HYPullDown*)this;		_HYRect * relRect = (_HYRect*)p;	Rect    cRect;	cRect.left = relRect->left;	cRect.right = relRect->right;	cRect.top = relRect->top;	cRect.bottom = relRect->bottom;	if (!(theParent->settings.width&HY_COMPONENT_TRANSP_BG))		FillCRect (&cRect,backFill);	else		EraseRect (&cRect);			if (theParent->MenuItemCount())		DrawMenuPlaceHolder (menuRect,*theParent->GetMenuItem(selection),theParent->IsEnabled()&&theParent->activationFlag);	 	(*theParent)._HYPlatformComponent::_Paint(p);}//__________________________________________________________________ _HYRect	_HYPullDown::_SuggestDimensions (void) { 	_HYRect res = {25,100,25,100,HY_COMPONENT_NO_SCROLL};	#ifdef OPAQUE_TOOLBOX_STRUCTS 		if (myMenu) 			res.right = GetMenuWidth (myMenu)+22;	#else 		if (myMenu) 			res.right = (*myMenu)->menuWidth+22;	#endif 	return res; } //__________________________________________________________________void	_HYPullDown::_SetMenuItemTextStyle (long ID, char style){ 	if (myMenu) 		SetItemStyle (myMenu,ID+1,style);}//__________________________________________________________________bool _HYPullDown::_ProcessOSEvent (Ptr vEvent){	EventRecord*	theEvent = (EventRecord*)vEvent;	if (myMenu)		switch (theEvent->what)		{			case mouseDown:			{				if (enabledFlag)				{					Point localClick = theEvent->where;					GlobalToLocal (&localClick);					if (PtInRect(localClick,&menuRect))					{						if (messageRecipient)							messageRecipient->ProcessEvent (generateMenuOpenEvent (GetID()));							localClick.v = menuRect.top;						localClick.h = menuRect.left;						LocalToGlobal(&localClick);						SetItemMark (myMenu,selection+1,checkMark);						unsigned long res = PopUpMenuSelect (myMenu,localClick.v, localClick.h, selection+1);						SetItemMark (myMenu,selection+1,noMark);						if (HiWord(res)!=0)						{							selection = LoWord(res)-1;							SendSelectionChange();							_MarkForUpdate();						}					}				}				return true;			}		}	return _HYPlatformComponent::_ProcessOSEvent (vEvent);		}//__________________________________________________________________//___________________________________________________________________HYPlatformButtonBar::_HYPlatformButtonBar(void){	backFill = NewPixPat();	if (!backFill)	{		warnError (-108);	}	RGBColor  wht = {0xffff,0xffff,0xffff};	MakeRGBPat (backFill,&wht);	pushed = -1;	saveMousePosH = -1;	saveMousePosV = -1;	lastSave = 0;	toolTipBounds.left = 0;	#ifdef TARGET_API_MAC_CARBON		//EventLoopRef 	  mainLoop;		//mainLoop = GetMainEventLoop();		timerUPP = NewEventLoopTimerUPP(ButtonBarTimer);		//InstallEventLoopTimer (mainLoop,0,1.5*kEventDurationSecond,timerUPP,this,&theTimer);		theTimer = nil;	#endif}		//___________________________________________________________________HYPlatformButtonBar::~_HYPlatformButtonBar(void){	if (backFill)	{		DisposePixPat (backFill);	}	#ifdef TARGET_API_MAC_CARBON		if (theTimer)			RemoveEventLoopTimer (theTimer);		DisposeEventLoopTimerUPP (timerUPP);	#endif}//__________________________________________________________________void	_HYPlatformButtonBar::_DisposeButtons(void){	_HYButtonBar* theParent = (_HYButtonBar*)this;	for (long i=0; i<theParent->ButtonCount(); i++)	{		CIconHandle thisIcon = (CIconHandle)theParent->buttons.lData[i];		DisposeCIcon (thisIcon);	}}//__________________________________________________________________void	_HYPlatformButtonBar::_DisposeButton(long k){	_HYButtonBar* theParent = (_HYButtonBar*)this;	if ((k<theParent->ButtonCount())&&(k>=0))	{		CIconHandle thisIcon = (CIconHandle)theParent->buttons.lData[k];		DisposeCIcon (thisIcon);	}}//__________________________________________________________________void		_HYPlatformButtonBar::_SetBackColor (_HYColor& c){	RGBColor newBG;	newBG.red = c.R*256;	newBG.blue = c.B*256;	newBG.green = c.G*256;	MakeRGBPat (backFill,&newBG);}//__________________________________________________________________void		_HYPlatformButtonBar::_SetVisibleSize (_HYRect rel){	_HYButtonBar* theParent = (_HYButtonBar*) this;	buttonRect.left=rel.left;	buttonRect.top = rel.top;	_HYRect s = theParent->_SuggestDimensions();	buttonRect.right = buttonRect.left+s.right;	buttonRect.bottom = buttonRect.top+s.bottom;	AlignRectangle (rel, buttonRect, theParent->GetAlignFlags());}//__________________________________________________________________void		_HYButtonBar::_Activate (void){	if (!activationFlag)		for (long k=0; k<enabledButtons.lLength; k++)			_MarkButtonForUpdate (enabledButtons.lData[k]);	if (!theTimer)	{		EventLoopRef 	  mainLoop;		mainLoop = GetMainEventLoop();		InstallEventLoopTimer (mainLoop,0,.5*kEventDurationSecond,timerUPP,this,&theTimer);	}	_HYPlatformComponent::_Activate();}//__________________________________________________________________void		_HYButtonBar::_Deactivate (void){	if (activationFlag)	{		for (long k=0; k<enabledButtons.lLength; k++)			_MarkButtonForUpdate (enabledButtons.lData[k]);		if (toolTipBounds.left)		{			#ifdef TARGET_API_MAC_CARBON				InvalWindowRect (parentWindow,&toolTipBounds);				//HMHideTag ();			#else				InvalRect (&toolTipBounds);			#endif			toolTipBounds.left = 0;					}	}		#ifdef TARGET_API_MAC_CARBON		if (theTimer)		{			RemoveEventLoopTimer(theTimer);			theTimer = nil;		}	#endif	_HYPlatformComponent::_Deactivate();}//__________________________________________________________________void		_HYButtonBar::_ComponentMouseExit (void){	if (toolTipBounds.left)	{		#ifdef TARGET_API_MAC_CARBON			InvalWindowRect (parentWindow,&toolTipBounds);			//HMHideTag ();		#else			InvalRect (&toolTipBounds);		#endif		toolTipBounds.left = 0;	}	#ifdef TARGET_API_MAC_CARBON		if (theTimer)		{			RemoveEventLoopTimer(theTimer);			theTimer = nil;		}	#endif}//__________________________________________________________________void		_HYPlatformButtonBar::_Paint (Ptr p){	_HYButtonBar * theParent = (_HYButtonBar*)this;	_HYRect * relRect = (_HYRect*)p;	Rect    cRect,iRect;	cRect.left = relRect->left;	cRect.right = relRect->right;	cRect.top = relRect->top;	cRect.bottom = relRect->bottom;	if (!(theParent->settings.width&HY_COMPONENT_TRANSP_BG))		FillCRect (&cRect,backFill);	else		EraseRect (&cRect); 	RgnHandle saveRgn = NewRgn(); 	 			  	if (!saveRgn) 		warnError(-108); 		 	GetClip (saveRgn); 	ClipRect (&cRect); 	cRect.left = buttonRect.left; 	cRect.top = buttonRect.top; 	int	  step = theParent->GetButtonDim()+2*HY_BUTTONBAR_BORDER; 	cRect.right = cRect.left+step; 	cRect.bottom = cRect.top+step; 	RGBColor saveColor; 	GetForeColor (&saveColor);	RGBForeColor (&buttonBorder1); 	PenSize (1,1);  	for (long i=0; i<theParent->ButtonCount(); i++) 	{ 		if (i&&(i%theParent->BarWidth()==0)) 		{ 			cRect.left = buttonRect.left; 			cRect.top +=step; 			cRect.bottom +=step;		 	cRect.right = cRect.left+step; 		} 		iRect = cRect; 		//ThemeButtonDrawInfo binfo = {theParent->activationFlag?kThemeStateActive:kThemeStateInactive,kThemeButtonOff,kThemeAdornmentNone};		//DrawThemeButton (&iRect,kThemeBevelButton,&binfo,nil,nil,nil,0); 		InsetRect (&iRect,HY_BUTTONBAR_BORDER,HY_BUTTONBAR_BORDER); 		if (theParent->activationFlag)	 		if (i==pushed)	  			PlotCIconHandle (&iRect,atNone,ttSelected,(CIconHandle)theParent->buttons.lData[i]);	 		else	 		{		 		if (theParent->enabledButtons.Find(i)>=0)		  			PlotCIcon (&iRect,(CIconHandle)theParent->buttons.lData[i]);		  		else		  			PlotCIconHandle (&iRect,atNone,ttDisabled,(CIconHandle)theParent->buttons.lData[i]);		  	}		else		  	PlotCIconHandle (&iRect,atNone,ttDisabled,(CIconHandle)theParent->buttons.lData[i]);  					MoveTo (iRect.left-1,iRect.top-1);		LineTo (iRect.right+1,iRect.top-1);		LineTo (iRect.right+1,iRect.bottom+1);		LineTo (iRect.left-1,iRect.bottom+1);		LineTo (iRect.left-1,iRect.top-1);		 		cRect.left +=step; 		cRect.right +=step; 	} 	 	RGBForeColor (&saveColor); 	SetClip    (saveRgn); 	DisposeRgn (saveRgn); 	 	(*theParent)._HYPlatformComponent::_Paint(p);}//__________________________________________________________________ _HYRect	_HYPlatformButtonBar::_GetButtonRect (bool conv) { 	_HYRect res; 	res.left   = buttonRect.left;	res.right  = buttonRect.right;	res.top    = buttonRect.top;	res.bottom = buttonRect.bottom;	if (conv)	{ 		GrafPtr thisPort; 		GetPort (&thisPort); 		#ifdef OPAQUE_TOOLBOX_STRUCTS  			SetPort (GetWindowPort(((_HYButtonBar*)this)->parentWindow));		 		#else			SetPort (((_HYButtonBar*)this)->parentWindow);		#endif		Point   c;		c.v = res.top;		c.h = res.left;		LocalToGlobal(&c);		res.top = c.v;		res.left = c.h;		c.v = res.bottom;		c.h = res.right;		LocalToGlobal(&c);		res.bottom = c.v;		res.right = c.h;		SetPort (thisPort);	}	return res; }//__________________________________________________________________ _HYRect	_HYButtonBar::_SuggestDimensions (void) {  	_HYRect res = {10,10,10,10,HY_COMPONENT_NO_SCROLL}; 	int w = ButtonCount(), h=1; 	if (w>BarWidth()) 	{ 		w = BarWidth(); 		h = ButtonCount()/w+1; 	} 	res.right =  w*(buttonDim+2*HY_BUTTONBAR_BORDER);  	res.bottom = h*(buttonDim+2*HY_BUTTONBAR_BORDER);	return res; } //__________________________________________________________________void		_HYPlatformButtonBar::_Update (Ptr p){	_Paint (p);} //__________________________________________________________________void		_HYPlatformButtonBar::_MarkButtonForUpdate (int i){	_HYButtonBar* theParent = (_HYButtonBar*)this;	if ((i>=0)&&(i<theParent->ButtonCount()))	{		int hR = i%theParent->BarWidth(),			vR = i/theParent->BarWidth(),			step = 2*HY_BUTTONBAR_BORDER+theParent->GetButtonDim();					Rect invRect;		invRect.left  = buttonRect.left+hR*step;		invRect.right = invRect.left+step;		invRect.top   = buttonRect.top+vR*step;		invRect.bottom= invRect.top+step;		GrafPtr savePort;		GetPort (&savePort); 		#ifdef OPAQUE_TOOLBOX_STRUCTS 			SetPort (GetWindowPort(theParent->parentWindow)); 		#else			SetPort (theParent->parentWindow);		#endif		#ifdef TARGET_API_MAC_CARBON			InvalWindowRect (theParent->parentWindow,&invRect);		#else			InvalRect (&invRect);		#endif		if (forceUpdateForScrolling)		{			Rect	rel = HYRect2Rect (theParent->rel);			SectRect (&rel,&invRect,&invRect);			_HYRect br = {invRect.top,invRect.left,invRect.bottom,invRect.right,0};			theParent->Paint((Ptr)&br);		}		SetPort (savePort);	}}//__________________________________________________________________void		_HYPlatformButtonBar::_UnpushButton (void){	if (pushed>=0)	{		_MarkButtonForUpdate(pushed);		pushed = -1;	}} //__________________________________________________________________void		_HYPlatformButtonBar::_SetDimensions (_HYRect r, _HYRect rel){	_HYButtonBar* theParent = (_HYButtonBar*) this;	theParent->_HYPlatformComponent::_SetDimensions (r,rel);	_SetVisibleSize (rel);} //__________________________________________________________________int 		_HYPlatformButtonBar::_FindClickedButton (int h, int v){	Point localClick = {v,h};	_HYButtonBar * parent = (_HYButtonBar*)this;	if (PtInRect (localClick,&buttonRect))	{		int v = localClick.v-buttonRect.top,			h = localClick.h-buttonRect.left,			step = 2*HY_BUTTONBAR_BORDER+parent->buttonDim,			hR = h/step,			vR = v/step;					v-=vR*step;		h-=hR*step;		if ((v>HY_BUTTONBAR_BORDER)&&(v<step-HY_BUTTONBAR_BORDER)&&			(h>HY_BUTTONBAR_BORDER)&&(h<step-HY_BUTTONBAR_BORDER))			return hR+vR*parent->barW;	}	return -1;}//__________________________________________________________________#ifdef TARGET_API_MAC_CARBON	pascal void ButtonBarTimer (EventLoopTimerRef theTimer,void* userData)	{		Point	 curMouse;		GetGlobalMouse (&curMouse);		//LocalToGlobal (&curMouse);		_HYButtonBar * myBB = (_HYButtonBar*)userData;		unsigned long t;		GetDateTime(&t);				if ((curMouse.h==myBB->saveMousePosH)		   &&(curMouse.v==myBB->saveMousePosV))		{			if (!myBB->toolTipBounds.left)			{				GrafPtr curPort;				GetPort (&curPort);				SetPort (GetWindowPort (myBB->parentWindow));				myBB->_DisplayToolTip();					SetPort (curPort);				}		}				myBB->saveMousePosH = curMouse.h;		myBB->saveMousePosV = curMouse.v;		myBB->lastSave		= t;	}	#endif//__________________________________________________________________void		_HYButtonBar::_DisplayToolTip	   (void){	Point p = {saveMousePosV,saveMousePosH};	GlobalToLocal (&p);	int h = _FindClickedButton (p.h,p.v);		/*#ifdef TARGET_API_MAC_CARBON	if (h>-1)	{		_String* toolTip = (_String*)toolTips(h);		if (toolTip->sLength)		{			int x, 				y;							GetButtonLoc (h,x,y,true);			HMHelpContentRec hmr;						hmr.absHotRect.left  = x;			hmr.absHotRect.top   = y;			hmr.absHotRect.right = x+GetButtonDim();			hmr.absHotRect.bottom= y+GetButtonDim();						hmr.version = kMacHelpVersion;			hmr.tagSide = kHMDefaultSide;						hmr.content[0].contentType = kHMPascalStrContent;			hmr.content[1].contentType = kHMPascalStrContent;			StringToStr255 (*toolTip,hmr.content[0].u.tagString);			StringToStr255 (*toolTip,hmr.content[1].u.tagString);						HMDisplayTag (&hmr);			toolTipBounds.left = 1;		}	}	#else*/	if ((h>-1)&&(h<toolTips.lLength))	{		_String* toolTip = (_String*)toolTips(h);		if (toolTip->sLength)		{			//RGBColor      toolTipColor = {0x0000,0x3A00,0x8A00};			RGBColor      toolTipColor = {0xFFFF,0xCCFF,0x6600};			PixPatHandle  toolTipPixPat = NewPixPat();			MakeRGBPat (toolTipPixPat,&toolTipColor);			int		   bL,bT;			GetButtonLoc (h,bL,bT,false);		 	GrafPtr thisPort;		 	GetPort (&thisPort);			#ifdef OPAQUE_TOOLBOX_STRUCTS				short	savedFace = GetPortTextFont (thisPort), 			 			savedSize = GetPortTextSize	(thisPort);			 						 	Style	savedStyle = GetPortTextFace (thisPort);			#else				short	savedFace = thisPort->txFont, 			 			savedSize = thisPort->txSize;			 						 	Style	savedStyle = thisPort->txFace;			#endif		 	TextFont (kFontIDHelvetica);		 	TextSize (12);		 	TextFace (0);			toolTipBounds.bottom = bT-1;			toolTipBounds.top = toolTipBounds.bottom - 15;			if (toolTipBounds.top<0)			{				toolTipBounds.top = bT+buttonDim+1;				toolTipBounds.bottom = toolTipBounds.top+15;			}			h = GetVisibleStringWidth (*toolTip)+4;			toolTipBounds.left = bL+(buttonDim-h-1)/2;			if (toolTipBounds.left<=0) 				toolTipBounds.left = 1;			toolTipBounds.right = toolTipBounds.left+h+2;	 		#ifdef OPAQUE_TOOLBOX_STRUCTS 	 			Rect portRect;	 			GetPortBounds (thisPort,&portRect);				h = toolTipBounds.right-portRect.right+portRect.left;	 		#else				h = toolTipBounds.right-thisPort->portRect.right+thisPort->portRect.left;			#endif			if (h>0)			{				if (h>=toolTipBounds.left)					h = toolTipBounds.left-1;				toolTipBounds.left -= h;				toolTipBounds.right-= h;			}		 	RGBColor oldColor;		 	GetForeColor (&oldColor);		 	toolTipColor.red = toolTipColor.blue = toolTipColor.green = 0x0000;		  	RGBForeColor (&toolTipColor);			FillCRect  (&toolTipBounds,toolTipPixPat);			FrameRect  (&toolTipBounds);			MoveTo (toolTipBounds.left+3,toolTipBounds.bottom-3);		 	DrawText (toolTip->sData,0,toolTip->sLength);		 	RGBForeColor (&oldColor);		 	TextFont (savedFace);		 	TextSize (savedSize);		 	TextFace (savedStyle);			DisposePixPat (toolTipPixPat);		}	}	//#endif}//__________________________________________________________________bool _HYButtonBar::_ProcessOSEvent (Ptr vEvent){	EventRecord*	theEvent = (EventRecord*)vEvent;	WindowPtr		dummy;	#ifdef			TARGET_API_MAC_CARBON		if (!theTimer)		{			EventLoopRef 	  mainLoop;			mainLoop = GetMainEventLoop();			InstallEventLoopTimer (mainLoop,0,.5*kEventDurationSecond,timerUPP,this,&theTimer);		}	#endif	if (buttons.lLength)		switch (theEvent->what)		{			case mouseDown:			{				if (toolTipBounds.left)				{					#ifdef TARGET_API_MAC_CARBON						InvalWindowRect (parentWindow,&toolTipBounds);						//HMHideTag ();					#else						InvalRect (&toolTipBounds);					#endif					toolTipBounds.left = 0;					GetDateTime (&lastSave);				}				long evtType = FindWindow (theEvent->where,&dummy);				switch (evtType)				{					case inContent:					{						Point localClick = theEvent->where;						GlobalToLocal (&localClick);						int h = _FindClickedButton (localClick.h,localClick.v);						if ((h>=0)&&(enabledButtons.Find(h)>=0))						{							if (pullDownButtons.Find(h)<0)							{								long lastFound = h,									 cf;								forceUpdateForScrolling = true;								pushed = h;								_MarkButtonForUpdate (h);								#ifdef TARGET_API_MAC_CARBON									MouseTrackingResult  trackingResult = kMouseTrackingMousePressed;									GetMouse (&localClick);									while (trackingResult != kMouseTrackingMouseReleased)									{										TrackMouseLocation (NULL, &localClick, &trackingResult);										cf = _FindClickedButton(localClick.h,localClick.v);										if (cf!=lastFound)										{											if (lastFound==h)											{												pushed = -1;												_MarkButtonForUpdate (h);											}											else											 	if (cf==h)												{													pushed = h;													_MarkButtonForUpdate (h);												}											 											lastFound = cf;										}									}								#else									while (WaitMouseUp())									{										GetMouse (&localClick);										cf = _FindClickedButton(localClick.h,localClick.v);										if (cf!=lastFound)										{											if (lastFound==h)											{												pushed = -1;												_MarkButtonForUpdate (h);											}											else											 	if (cf==h)												{													pushed = h;													_MarkButtonForUpdate (h);												}											 											lastFound = cf;										}									}																#endif								pushed = -1;								forceUpdateForScrolling = false;							}							if (_FindClickedButton(localClick.h,localClick.v)==h)							{								//pushed = h;								pushed = -1;								forceUpdateForScrolling = true;								_MarkButtonForUpdate (h);								forceUpdateForScrolling = false;								SendButtonPush(h);							}						}						return true;					}				}				break;			}			default:			{				if (!StillDown())				{					if (pushed>=0)					{						_MarkButtonForUpdate (pushed);						pushed = -1;						return true;					}					if (theEvent->what == osEvt)					{						unsigned long t;						GetDateTime(&t);						if ((theEvent->where.h==saveMousePosH)						   &&(theEvent->where.v==saveMousePosV))						{							if ((t-lastSave>1)&&(!toolTipBounds.left))							{								_DisplayToolTip();								lastSave = t;							}						}						else						{							if (toolTipBounds.left)							{								#ifdef TARGET_API_MAC_CARBON									InvalWindowRect (parentWindow,&toolTipBounds);									//HMHideTag ();								#else									InvalRect (&toolTipBounds);								#endif								toolTipBounds.left = 0;							}							saveMousePosH = theEvent->where.h;							saveMousePosV = theEvent->where.v;							lastSave = t;						}						return true;					}				}			}		}	return _HYPlatformComponent::_ProcessOSEvent (vEvent);		}//__________________________________________________________________//___________________________________________________________________HYPlatformList::_HYPlatformList(void){	listData = nil;}		//___________________________________________________________________HYPlatformList::~_HYPlatformList(void){	if (listData)	{		LDispose (listData);	}}//__________________________________________________________________void	_HYList::_Activate(void){	if (listData)	{		LActivate (true, listData);	}	_HYPlatformComponent::_Activate();}//__________________________________________________________________void	_HYList::_Deactivate(void){	if (listData)	{		LActivate (false, listData);	}	_HYPlatformComponent::_Deactivate();}//__________________________________________________________________void		_HYPlatformList::_SetVisibleSize (_HYRect rel){	_HYList* theParent = (_HYList*) this;	if (listData)		LDispose(listData);			SetWindowFont (fontID, theParent->GetFont().size, theParent->GetFont().style, true);	Rect	 listBox = {rel.top+1,rel.left,rel.bottom,rel.right-HY_SCROLLER_WIDTH}, 			 listDim = {0,0,theParent->ItemCount(),1};	Point	 cellSize = {0,0};	listData = LNew(&listBox,&listDim,cellSize,0,(WindowPtr)theParent->parentWindow,true,false,false,true);	checkPointer ((Ptr)listData);	(*listData)->selFlags = lNoNilHilite|lUseSense;	for (long k=0;k<theParent->ItemCount();k++)		_SetItem (*theParent->GetItem(k),k);	SetWindowFont (0,0,0,false);}//__________________________________________________________________void		_HYPlatformList::_Paint (Ptr p){	_HYRect * relRec = (_HYRect*)p;	Rect r;	r.left = relRec->left;	r.right = relRec->right;	r.top = relRec->top;	r.bottom = relRec->bottom;	EraseRect (&r);	if (listData)	{		_HYList* theParent = (_HYList*)this;		SetWindowFont (fontID, theParent->GetFont().size, theParent->GetFont().style, true);		LActivate (true,listData);		LUpdate (GetGrayRgn(),listData);		SetWindowFont (0,0,0,false);	}}//__________________________________________________________________void		_HYList::_EraseRect (_HYRect relRec){	Rect r;	r.left = relRec.left;	r.right = relRec.right;	r.top = relRec.top;	r.bottom = relRec.bottom;	EraseRect (&r);}//__________________________________________________________________void		_HYPlatformList::_Update (Ptr p){	_Paint (p);} //__________________________________________________________________void		_HYPlatformList::_SetDimensions (_HYRect r, _HYRect rel){	_HYList* theParent = (_HYList*) this;	theParent->_HYPlatformComponent::_SetDimensions (r,rel);	_SetVisibleSize (rel);} //__________________________________________________________________void		_HYPlatformList::_SetFont (void){	_HYList* theParent = (_HYList*)this;	Str255 fName;	StringToStr255 (theParent->GetFont().face,fName);	GetFNum (fName,&fontID);} //__________________________________________________________________bool _HYList::_ProcessOSEvent (Ptr vEvent){	EventRecord*	theEvent = (EventRecord*)vEvent;		if (listData)	{		if(theEvent->what==mouseDown)		{				Point localClick = theEvent->where;			GlobalToLocal (&localClick);			if (LClick (localClick,theEvent->modifiers,listData))			{				_CheckSelection();				if (selection.lLength==1)				{					SendDblClickEvent(selection.lData[0]);					return true;				}			}			else				_CheckSelection();			if (messageRecipient)			{				messageRecipient->ProcessEvent(generateKeyboardFocusEvent(GetID()));			}			return true;		}		else		if((theEvent->what==keyDown)||(theEvent->what==autoKey))		{			unsigned char keyCode = (theEvent->message&keyCodeMask)>>8;			Cell	 thisCell={0,0};			if (selection.lLength==1)			{				if (keyCode==0x7E) // up arrow				{					if (selection.lData[0])					{						thisCell.v = selection.lData[0];						LSetSelect (false,thisCell,listData);						selection.lData[0]--;						thisCell.v--;						LSetSelect (true,thisCell,listData);						LAutoScroll(listData);						_MarkForUpdate();						SendSelectionChange();						return true;					}				}				else				if (keyCode==0x7D) // down arrow				{					if (selection.lData[0]<items.lLength-1)					{						thisCell.v = selection.lData[0];						LSetSelect (false,thisCell,listData);						selection.lData[0]++;						thisCell.v++;						LSetSelect (true,thisCell,listData);						LAutoScroll(listData);						_MarkForUpdate();						SendSelectionChange();						return true;					}				}							}		}	}	return _HYPlatformComponent::_ProcessOSEvent (vEvent);		}//__________________________________________________________________void _HYPlatformList::_ToggleMultSelection (bool flag){	if (listData)	{		if (flag)			(*listData)->selFlags&=0x7F;		else			(*listData)->selFlags|=0x80;	}}//__________________________________________________________________void _HYPlatformList::_CheckSelection (void){	if (listData)	{		_HYList * theParent = (_HYList*)this;		_SimpleList newSelection;		Cell		scrollCell = {0,0};		while (LGetSelect (true,&scrollCell,listData))		{			newSelection<<scrollCell.v;			scrollCell.v++;		}		if (!theParent->GetSelection().Equal(newSelection))		{			theParent->GetSelection().Clear();			theParent->GetSelection().Duplicate (&newSelection);			theParent->SendSelectionChange();		}	}}//__________________________________________________________________void _HYPlatformList::_SetSelection (_SimpleList& nSel){	if (listData)	{		_KillSelection();		if (nSel.lLength)		{			Cell scrollCell = {0,0};			for (long k=0;k<nSel.lLength;k++)			{				scrollCell.v = nSel.lData[k];				LSetSelect (true,scrollCell,listData);			}			LAutoScroll (listData);		}	}}//__________________________________________________________________void _HYPlatformList::_KillSelection (void){	if (listData)	{		_HYList * theParent = (_HYList*)this;		Cell		scrollCell = {0,0};		while (LGetSelect (true,&scrollCell,listData))		{			LSetSelect (false,scrollCell,listData);			scrollCell.v++;		}	}}//__________________________________________________________________void _HYPlatformList::_InsertItem (_String& item, long index){	if (listData)	{		if (index<0) index = 10000;		index = LAddRow(1,index,listData);		Cell	thisCell = {index,0};		LSetCell(item.sData,item.sLength,thisCell,listData);	}}//__________________________________________________________________void _HYPlatformList::_SetItem (_String& item, long index){	if (listData)	{		Cell	thisCell = {index,0};		LSetCell(item.sData,item.sLength,thisCell,listData);	}}//__________________________________________________________________void _HYList::_ToggleDrawing (bool onOff){	if (listData)	{		LSetDrawingMode (onOff,listData);	}}//__________________________________________________________________void _HYPlatformList::_DeleteItem (long index){	if (listData)		LDelRow(1,index,listData);	//_CheckSelection();}//___________________________________________________________________HYPlatformTable::_HYPlatformTable(void){	fontID = 0;	backPattern  = NewPixPat();	backPattern2 = NewPixPat();	cursorState  = false;	editBox		 = nil;	}//___________________________________________________________________HYPlatformTable::~_HYPlatformTable(void){	DisposePixPat (backPattern);	DisposePixPat (backPattern2);}//__________________________________________________________________void		_HYPlatformTable::_SetFont (void){	_HYTable* parent = (_HYTable*)this;	Str255 fName;	StringToStr255 (parent->textFont.face,fName);	short fNum=0;	GetFNum (fName,&fNum);	fontID = fNum;}//__________________________________________________________________void 		_HYTable::_HScrollTable (long h){	if (h)	{			GrafPtr   savePort;		GetPort   (&savePort); 		#ifdef OPAQUE_TOOLBOX_STRUCTS 			SetPort   (GetWindowPort(parentWindow)); 		#else			SetPort   (parentWindow);		#endif		long		vsShift = ((settings.width&HY_COMPONENT_H_SCROLL)?HY_SCROLLER_WIDTH:0),					hsShift = ((settings.width&HY_COMPONENT_V_SCROLL)?HY_SCROLLER_WIDTH:0);		EditBoxHandler	(-1,rel);		if (abs(h)>(rel.right-rel.left)/2)		{			_Paint((Ptr)&rel);		}		else		{			RgnHandle updateRgn = NewRgn();			checkPointer (updateRgn);			Rect 	  scrollRect;			_HYRect	  paintRect;			scrollRect.top = rel.top;			scrollRect.bottom = rel.bottom-vsShift;			scrollRect.right = rel.right-hsShift;			scrollRect.left  = rel.left;			paintRect.top = scrollRect.top;			paintRect.bottom = rel.bottom;			if (h>0)			{				ScrollRect (&scrollRect,-h,0,updateRgn);				paintRect.right = scrollRect.right+hsShift;				paintRect.left = scrollRect.right-h;				hOrigin+=paintRect.left-rel.left;				Paint((Ptr)&paintRect);				hOrigin-=paintRect.left-rel.left;			}			else			{				ScrollRect (&scrollRect,-h,0,updateRgn);				paintRect.left = scrollRect.left;				paintRect.right = paintRect.left-h+hsShift;				Paint((Ptr)&paintRect);			}			DisposeRgn (updateRgn);		}		SetPort (savePort);	}}//__________________________________________________________________void 		_HYTable::_VScrollTable (long v){	if (v)	{		GrafPtr   savePort;		GetPort   (&savePort); 		#ifdef OPAQUE_TOOLBOX_STRUCTS 			SetPort   (GetWindowPort(parentWindow)); 		#else			SetPort   (parentWindow);		#endif		long		vsShift = ((settings.width&HY_COMPONENT_H_SCROLL)?HY_SCROLLER_WIDTH:0),					hsShift = ((settings.width&HY_COMPONENT_V_SCROLL)?HY_SCROLLER_WIDTH:0);		EditBoxHandler	(-1,rel);		if (abs(v)>(rel.bottom-rel.top)/2)		{			_Paint((Ptr)&rel);		}		else		{			RgnHandle updateRgn = NewRgn();			checkPointer (updateRgn);			Rect 	  scrollRect;			_HYRect	  paintRect;			scrollRect.left = rel.left;			scrollRect.right = rel.right-hsShift;			paintRect.left = scrollRect.left;			paintRect.right = rel.right;			scrollRect.top = rel.top;			scrollRect.bottom  = rel.bottom-vsShift;			if (v>0)			{				ScrollRect (&scrollRect,0,-v,updateRgn);				paintRect.top = rel.bottom-vsShift-v-1;				paintRect.bottom = rel.bottom;				vOrigin+=paintRect.top-rel.top;				Paint((Ptr)&paintRect);				vOrigin-=paintRect.top-rel.top;			}			else			{				ScrollRect (&scrollRect,0,-v,updateRgn);				paintRect.top = rel.top;				paintRect.bottom = rel.top-v+vsShift+2;				Paint((Ptr)&paintRect);			}			DisposeRgn (updateRgn);		}			SetPort (savePort);	}}//__________________________________________________________________extern		Cursor		hSizeCursor,						editStateCursor;extern		CCrsrHandle pickUpCursor,						dropOffCursor;			//__________________________________________________________________void		_HYTable::_ComponentMouseExit (void){	if (cursorState)	{		cursorState = 0;		#ifdef TARGET_API_MAC_CARBON			Cursor arrow;			SetCursor(GetQDGlobalsArrow(&arrow));				#else			SetCursor (&qd.arrow);		#endif	}}//__________________________________________________________________bool 		_HYTable::_ProcessOSEvent (Ptr vEvent){	EventRecord*	theEvent = (EventRecord*)vEvent;	WindowPtr		dummy;		static	UInt32	lastClick = 0;	static	int 	lastH = 0, lastV = 0;		long			k,h,v,					vsShift = ((settings.width&HY_COMPONENT_H_SCROLL)?HY_SCROLLER_WIDTH:0),					hsShift = ((settings.width&HY_COMPONENT_V_SCROLL)?HY_SCROLLER_WIDTH:0);		switch (theEvent->what)	{		case mouseDown:		{			Point p = theEvent->where;			GlobalToLocal (&p);			bool	dblClick = (theEvent->when-lastClick<GetDblTime())&&						       (abs(p.h-lastH)<5)&&						       (abs(p.v-lastV)<5);			lastClick = theEvent->when;			lastH = p.h;			lastV = p.v;						if ((selectionType&HY_TABLE_FOCUSABLE)&&messageRecipient&&((selectionType&HY_TABLE_IS_FOCUSED)==0))			{				messageRecipient->ProcessEvent(generateKeyboardFocusEvent (GetID()));				//return true;			}						long evtType = FindWindow (theEvent->where,&dummy);			switch (evtType)			{				case inContent:				{					if (cursorState == HY_TABLE_SIZE_CURSOR)					{						EditBoxHandler (-1,rel);						RgnHandle		dragRgn = NewRgn();						checkPointer    (dragRgn);						Rect  limits;						limits.left = p.h;						limits.right = limits.left+1;						limits.top = rel.top;						limits.bottom = rel.bottom-vsShift;						RectRgn		  (dragRgn, &limits);						limits.right = rel.right-hsShift;												p.h+=hOrigin;						for (evtType = 0; evtType<horizontalSpaces.lLength-1; evtType++)							if (horizontalSpaces.lData[evtType]>p.h-2-rel.left) break;						if (evtType)							limits.left = rel.left+horizontalSpaces.lData[evtType-1]+3-hOrigin;						else							limits.left = rel.left+3;													long dragRes = horizontalSpaces.lData[horizontalSpaces.lLength-1]-									   rel.right+rel.left-hOrigin+hsShift;									   						if (dragRes<p.h-limits.left)							limits.left = p.h-dragRes;						p.h-=hOrigin;						dragRes = DragGrayRgn(dragRgn,p,&limits,&limits,hAxisOnly,nil);						DisposeRgn (dragRgn);						cursorState = false;						#ifdef TARGET_API_MAC_CARBON							Cursor arrow;							SetCursor(GetQDGlobalsArrow(&arrow));								#else							SetCursor (&qd.arrow);						#endif						if (dragRes!=kMouseUpOutOfSlop)						{							SetColumnSpacing (evtType,(short)(dragRes&0x0000ffff),true);							if (messageRecipient)								messageRecipient->ProcessEvent (generateTableResizeCEvent(GetID(),																evtType,(short)(dragRes&0x0000ffff)));						}					}					else					{												if (editBox&&PtInRect (p,&textBoxRect))						{							TEClick (p,theEvent->modifiers&shiftKey, editBox);						}						else						{							if (((k=FindClickedTableCell (p.h-rel.left,p.v-rel.top,h,v))>-1)&&								 (p.v<rel.bottom-vsShift)&&(p.h<rel.right-hsShift))							{								if (dblClick)								{									if (cellTypes.lData[k]&HY_TABLE_EDIT_TEXT)										EditBoxHandler (k,rel);									else										if (messageRecipient)											messageRecipient->ProcessEvent (generateTableDblClickEvent(GetID()));									break;								}								ModifySelection (h,v,theEvent->modifiers&shiftKey);							}														if (k==-2)							// process pull-down							{								if (messageRecipient)								{									messageRecipient->ProcessEvent (generateTablePullDownEvent(GetID(),v*horizontalSpaces.lLength+h,																    (((long)theEvent->where.h)<<16)+theEvent->where.v));								}								//_HandlePullDown (sampleMenu,theEvent->where.h,theEvent->where.v,2);								break;							}														if ((p.h<rel.right-hsShift)&&(p.v<rel.bottom-vsShift))								if (StillDown())								{									PenState 	savePen;									GetPenState (&savePen);									bool	first = true;									Point   newPt, oldPt = p;									long	t,t2 = -1;									FindClickedTableCell(p.h-rel.left,p.v-rel.top,h,t);														 									if (cursorState == HY_TABLE_DRAG_CURSOR)									{										SetCCursor (dropOffCursor);										//PenMode	   (patXor);										PenSize    (1,1);										while ( WaitMouseUp() ) 										{											GetMouse(&newPt);											if ((newPt.v>rel.bottom-vsShift)||(newPt.v<rel.top))											{												if (t2>=0)												{													_HiliteRowForDrag (t2,t);													t2 = -1;												}												h = verticalSpaces.lData[verticalSpaces.lLength-1]/verticalSpaces.lLength;												_ScrollVPixels ((newPt.v<rel.top)?-h:h);												continue;											}											if (newPt.h>rel.right-hsShift)												newPt.h=rel.right-hsShift;											if ( DeltaPoint(oldPt, newPt) ) 											{													k = FindClickedTableCell(newPt.h-rel.left,newPt.v-rel.top,h,v);												if ((v!=t2)&&(k>-1))												{													if (t2>=0)														_HiliteRowForDrag (t2,t);													if ((v!=t)&&(!(cellTypes.lData[k]&HY_TABLE_CANTSELECT)))													{														_HiliteRowForDrag (v,t);														t2 = v;													}													else														t2 = -1;												}												oldPt = newPt;											}										}										if (t2>=0)											_HiliteRowForDrag (t2,t);										SetCCursor (pickUpCursor);										if (t!=t2)										{											EditBoxHandler (-1,rel);											DragRow (t,t2);										}									}									else									{										if (((selectionType&HY_TABLE_SINGLE_SELECTION)==0)											&&((selectionType&HY_TABLE_NODRAG_SELECTION)==0))										{											PenSize (3,3);											PenMode (patXor);											Pattern	pPat; 											GetIndPattern (&pPat,0,4);											PenPat  (&pPat);																						Rect	outlineRect,													paintRect,													clippingRect;																								clippingRect = HYRect2Rect (rel);																						outlineRect.right  = outlineRect.left = p.h;											outlineRect.bottom = outlineRect.top  = p.v;												while ( WaitMouseUp() ) 											{												GetMouse(&newPt);												if (newPt.v>rel.bottom-vsShift)												{													if (rel.bottom-rel.top-vsShift+vOrigin <  verticalSpaces.lData[verticalSpaces.lLength-1]-1)													{														long h = verticalSpaces.lData[verticalSpaces.lLength-1]/verticalSpaces.lLength;														SectRect (&outlineRect,&clippingRect,&paintRect); FrameRect (&paintRect);														PenMode (patCopy);														SetPenState (&savePen);														_ScrollVPixels (h);														PenSize (3,3);														PenMode (patXor);														PenPat  (&pPat);														outlineRect.top -= h;														SectRect (&outlineRect,&clippingRect,&paintRect); FrameRect (&paintRect);														p.v -= h;														oldPt.v -= h;														continue;													}													newPt.v=rel.bottom-vsShift;												}												if (newPt.h>rel.right-hsShift)												{													if (rel.right-rel.left-hsShift+hOrigin <  horizontalSpaces.lData[horizontalSpaces.lLength-1]-1)													{														long h = horizontalSpaces.lData[horizontalSpaces.lLength-1]/horizontalSpaces.lLength;														SectRect (&outlineRect,&clippingRect,&paintRect); FrameRect (&paintRect);														PenMode (patCopy);														SetPenState (&savePen);														_ScrollHPixels (h);														PenSize (3,3);														PenMode (patXor);														PenPat  (&pPat);														outlineRect.left -= h;														SectRect (&outlineRect,&clippingRect,&paintRect); FrameRect (&paintRect);														p.h -= h;														oldPt.h -= h;														continue;													}													newPt.h=rel.right-hsShift;												}												if (newPt.v<rel.top)												{													if (vOrigin>0)													{														long h = verticalSpaces.lData[verticalSpaces.lLength-1]/verticalSpaces.lLength;														SectRect (&outlineRect,&clippingRect,&paintRect); FrameRect (&paintRect);														PenMode (patCopy);														SetPenState (&savePen);														_ScrollVPixels (-h);														PenSize (3,3);														PenMode (patXor);														PenPat  (&pPat);														outlineRect.top += h;														SectRect (&outlineRect,&clippingRect,&paintRect); FrameRect (&paintRect);														p.v += h;														oldPt.v += h;														continue;													}													newPt.v=rel.top;												}												if (newPt.h<rel.left)												{													if (hOrigin>0)													{														long h = horizontalSpaces.lData[horizontalSpaces.lLength-1]/horizontalSpaces.lLength;														SectRect (&outlineRect,&clippingRect,&paintRect); FrameRect (&paintRect);														PenMode (patCopy);														SetPenState (&savePen);														_ScrollHPixels (-h);														PenSize (3,3);														PenMode (patXor);														PenPat  (&pPat);														outlineRect.left += h;														SectRect (&outlineRect,&clippingRect,&paintRect); FrameRect (&paintRect);														p.h += h;														oldPt.h += h;														continue;													}													newPt.h=rel.left;												}																									if ( DeltaPoint(oldPt, newPt) ) 												{														if (!first)													{														SectRect (&outlineRect,&clippingRect,&paintRect); FrameRect (&paintRect);													}													if (newPt.h > p.h)													 	outlineRect.right = newPt.h;													else													{														outlineRect.right = p.h;														outlineRect.left = newPt.h;													}													if (newPt.v > p.v)													 	outlineRect.bottom = newPt.v;													else													{														outlineRect.bottom = p.v;														outlineRect.top = newPt.v;													}													SectRect (&outlineRect,&clippingRect,&paintRect); FrameRect (&paintRect);													first = false;													oldPt = newPt;												}											}																						if (!first)											{												SectRect (&outlineRect,&clippingRect,&paintRect); FrameRect (&paintRect);												_HYRect	    outlineHRect;												outlineHRect.left 	= outlineRect.left;												outlineHRect.right	= outlineRect.right+hsShift;												outlineHRect.top 	= outlineRect.top;												outlineHRect.bottom = outlineRect.bottom+vsShift;												long	hs,hf,vs,vf;												hOrigin += outlineRect.left-rel.left;												vOrigin += outlineRect.top-rel.top;												GetDisplayRange (&outlineHRect,hs,hf,vs,vf);												hOrigin -= outlineRect.left-rel.left;												vOrigin -= outlineRect.top-rel.top;												ExpungeSelection();												if ((hf>=hs)||(vs>=vf))												{													_SimpleList sel;													if (selectionType&HY_TABLE_SEL_ROWS)													{														for (h=vs;h<=vf;h++)															sel<<h;														SetRowSelection (sel);													}													else													if (selectionType&HY_TABLE_SEL_COLS)													{														for (v=hs;v<=hf;h++)															sel<<v;														SetColumnSelection(sel);																										}													else													{														for (h=hs;h<=hf;h++)															for (v=vs;v<=vf;v++)																sel << v*horizontalSpaces.lLength + h;														SetSelection (sel,true);														_MarkCellsForUpdate (sel);													}												}											}										}										SetPenState (&savePen);									}								}							}					}				}			}			break;		}		case keyDown:		case autoKey:		{			char	c = theEvent->message&charCodeMask,					k = (theEvent->message&keyCodeMask)>>8;								if (editBox)			{				if (theEvent->modifiers&cmdKey)				{					if ((c=='c')||(c=='C'))						TECopy (editBox);					else					if ((c=='x')||(c=='X'))						TECut (editBox);					else					if ((c=='v')||(c=='V'))						TEPaste (editBox);				}				else				{					if ((k==0x24)||(k==0x4C))						EditBoxHandler (-1,rel);					else						TEKey (c,editBox);				}				return true;			}			else				switch (k)				{					case 0x7E: // up						HandleKeyMove (0,theEvent->modifiers & cmdKey);						break;					case 0x7D: // down						HandleKeyMove (1,theEvent->modifiers & cmdKey);						break;					case 0x7B: // left						HandleKeyMove (2,theEvent->modifiers & cmdKey);						break;					case 0x7C: // right						HandleKeyMove (3,theEvent->modifiers & cmdKey);						break;				}							break;		}		default:		{			Point p = theEvent->where;			GlobalToLocal (&p);			if (cursorState == HY_TABLE_EDIT_CURSOR)			{				if (!(PtInRect (p,&textBoxRect)&&editBox))				{					#ifdef TARGET_API_MAC_CARBON						Cursor arrow;						SetCursor(GetQDGlobalsArrow(&arrow));							#else						SetCursor (&qd.arrow);					#endif					cursorState = 0;				}			}			else			{				if (editBox&&PtInRect (p,&textBoxRect))				{					SetCursor (&editStateCursor);					cursorState = HY_TABLE_EDIT_CURSOR;					break;				}			}			bool  ch = (!(selectionType&HY_TABLE_DONT_SIZE))&&(CheckForHSizeLocation(p.h-rel.left))&&(p.v<rel.bottom-vsShift);			if (ch&&(cursorState!=HY_TABLE_SIZE_CURSOR))			{				cursorState = HY_TABLE_SIZE_CURSOR;				SetCursor (&hSizeCursor);			}			else			if ((!ch)&&(cursorState==HY_TABLE_SIZE_CURSOR))			{				cursorState = 0;				#ifdef TARGET_API_MAC_CARBON					Cursor arrow;					SetCursor(GetQDGlobalsArrow(&arrow));						#else					SetCursor (&qd.arrow);				#endif			}			if (selectionType & HY_TABLE_SEL_ROWS)			{				if (!ch)				{					k = FindClickedTableCell(p.h-rel.left,p.v-rel.top,h,v);					if (k>=0)					{						if ((cursorState != HY_TABLE_DRAG_CURSOR)&&(cursorState != HY_TABLE_EDIT_CURSOR)&&							((selectionType&HY_TABLE_NODRAG_SELECTION)==0))						{							if (cellTypes.lData[k]&HY_TABLE_SELECTED)							{								if (IsRowSelectionSimple())								{									SetCCursor (pickUpCursor);									cursorState = HY_TABLE_DRAG_CURSOR;								}							}						}						else						{							if (((selectionType&HY_TABLE_NODRAG_SELECTION)==0)&&(!(cellTypes.lData[k]&HY_TABLE_SELECTED)))							{								#ifdef TARGET_API_MAC_CARBON									Cursor arrow;									SetCursor(GetQDGlobalsArrow(&arrow));										#else									SetCursor (&qd.arrow);								#endif								cursorState = 0;								}						}					}				}			}			//if (editBox)				//TEIdle (editBox);			return true;		}	}	return _HYPlatformComponent::_ProcessOSEvent (vEvent);		}//__________________________________________________________________extern	 	 Pattern	penHatchPattern,vertPenHatchPattern;extern		 RGBColor	menuLine1,						menuLine2;						extern		 CIconHandle						tablePDMenuIcon;						//__________________________________________________________________void		_HYTable::_Paint (Ptr p){		_HYRect 		*relRect 	= (_HYRect*)p; 	GrafPtr 		thisPort; 	RGBColor 		oldColor, 					oldBColor, 					whiteC = {0xffff,0xffff,0xffff}, 					fillColor = {0x8fff,0x8fff,0x8fff}; 					  	PixPatHandle	themeFill 	= nil;  	RgnHandle 		saveRgn 	= NewRgn();  	checkPointer 	(saveRgn);  	 	GetPort 		(&thisPort); 	GetForeColor 	(&oldColor); 	GetBackColor	(&oldBColor);	GetClip 		(saveRgn);	#ifdef OPAQUE_TOOLBOX_STRUCTS		short	savedFace = GetPortTextFont (thisPort), 	 			savedSize = GetPortTextSize	(thisPort);	 				 	Style	savedStyle = GetPortTextFace (thisPort);	#else		short	savedFace = thisPort->txFont, 	 			savedSize = thisPort->txSize;	 				 	Style	savedStyle = thisPort->txFace;	#endif  	 		long	hs, // starting column			hf, // ending column			vs, // starting row			vf, // ending row			k,	// loop index			t,  // aux variable			t2,			st; // a few more auxs				bool	chop,			chopv;				GetDisplayRange (relRect, hs, hf, vs, vf);		long			vsShift = ((settings.width&HY_COMPONENT_H_SCROLL)?HY_SCROLLER_WIDTH:0),					hsShift = ((settings.width&HY_COMPONENT_V_SCROLL)?HY_SCROLLER_WIDTH:0);			 	_HYRect			saveRel;	Rect			bRect;	GWorldPtr		offScreenPtr = nil;	CGrafPtr		savedCPtr;	GDHandle		savedDevice;		if ((vf-vs>2)&&(aquaInterfaceOn==false))	{		bRect.left    = bRect.top = 0;		bRect.right   = relRect->right-relRect->left-hsShift;		bRect.bottom  = relRect->bottom-relRect->top-vsShift;		short errCode = NewGWorld (&offScreenPtr,0,&bRect,0,GetMainDevice(),noNewDevice);		if (errCode != noErr)			offScreenPtr = nil;		else		{			if (!LockPixels (GetGWorldPixMap(offScreenPtr)))			{				ReportWarning ("Failed to lock pixels in _HYTable::_Paint");				DisposeGWorld (offScreenPtr);				offScreenPtr = nil;			}			else			{				GetGWorld (&savedCPtr,&savedDevice);				SetGWorld (offScreenPtr,nil);				//SetPort	 ((GrafPtr)offScreenPtr);				//SetOrigin (clipRect.left,clipRect.top);				saveRel = *relRect;				relRect->bottom -= relRect->top;				relRect->top = 0;				relRect->right  -= relRect->left;				relRect->left = 0;			}		}	}				 	Rect clipRect = {relRect->top,relRect->left,					 relRect->bottom-vsShift, 					 relRect->right-hsShift},		 anotherRect,		 clipRect2,		 clipRect3;		 		 	/*if (settings.width & HY_COMPONENT_BORDER_L)		clipRect.left ++;	if (settings.width & HY_COMPONENT_BORDER_T)		clipRect.top ++;	if (settings.width & HY_COMPONENT_BORDER_B)		if (!(settings.width&HY_COMPONENT_H_SCROLL))			clipRect.bottom--;	if (settings.width & HY_COMPONENT_BORDER_R)		if (!(settings.width&HY_COMPONENT_V_SCROLL))			clipRect.right--;*/	ClipRect (&clipRect);		anotherRect = clipRect;	t = relRect->top-vOrigin;	RGBForeColor (&whiteC);	for (k=vs;k<=vf;k++)	{		anotherRect.top = k?verticalSpaces.lData[k-1]+t:relRect->top;		anotherRect.bottom = verticalSpaces.lData[k]+t;		if (cellTypes.lData[k*horizontalSpaces.lLength]&HY_TABLE_BEVELED)		{			FillCRect (&anotherRect,backPattern2);			if ((k==vs)||(k<vf))			{				RGBForeColor (&menuLine2);				MoveTo (anotherRect.left,anotherRect.bottom-1);				LineTo (anotherRect.right,anotherRect.bottom-1);				RGBForeColor (&menuLine1);				MoveTo (anotherRect.left,anotherRect.bottom-2);				LineTo (anotherRect.right,anotherRect.bottom-2);				RGBForeColor (&whiteC);			}		}		else		{			FillCRect (&anotherRect,backPattern);			if ((k==vs)||(k<vf))			{				MoveTo (anotherRect.left,anotherRect.bottom-1);				LineTo (anotherRect.right,anotherRect.bottom-1);			}		}	}			if (hf<horizontalSpaces.lLength-1)		st = hf;	else		st = hf-1;	t = relRect->left-hOrigin-2;	if ((selectionType & HY_TABLE_NO_COLS_LINES) == 0)	{		RGBForeColor (&menuLine1);		for (k=hs;k<=st;k++)		{			t2 = t+horizontalSpaces.lData[k];			MoveTo (t2,relRect->top);			LineTo (t2,relRect->bottom);		}				RGBForeColor (&menuLine2);		t++;		for (k=hs;k<=st;k++)		{			t2 = t+horizontalSpaces.lData[k];			MoveTo (t2,relRect->top);			LineTo (t2,relRect->bottom);		}	}			RGBColor 	 textRGB = {((long)textColor.R) * 256, ((long)textColor.G) * 256, ((long)textColor.B) * 256};	RGBForeColor (&textRGB);		TextFont (fontID);	TextFace (textFont.style);	TextSize (textFont.size);	st = 0;	for (k=vs; k<=vf; k++)	{		anotherRect.top = relRect->top-vOrigin+1;		anotherRect.bottom = anotherRect.top+verticalSpaces.lData[k]-1;		if (k) anotherRect.top+=verticalSpaces.lData[k-1];		long 	t3,st2,				w = anotherRect.bottom-anotherRect.top,				w2,				shift = (w-textFont.size)/2-1;						if (anotherRect.bottom>relRect->bottom-vsShift)		{			anotherRect.bottom = relRect->bottom-vsShift;			chopv = false;		}		else			chopv = true;					for (t2=hs; t2<=hf; t2++)		{			t3 = k*horizontalSpaces.lLength+t2;			if (t3 == editCellID) continue;			anotherRect.left = relRect->left-hOrigin+1;			anotherRect.right = anotherRect.left+horizontalSpaces.lData[t2]-1;			if (t2) anotherRect.left+=horizontalSpaces.lData[t2-1];			clipRect2 = anotherRect;			w2= anotherRect.right-anotherRect.left;			chop = true;			if (anotherRect.right>relRect->right-hsShift)			{				anotherRect.right=relRect->right-hsShift;				chop = false;			}			else				chop = true;			if ((t2==hs)||(k==vs))			{				SectRect (&anotherRect,&clipRect,&clipRect3);				ClipRect (&clipRect3);			}			else				ClipRect (&anotherRect);			if (cellTypes.lData[t3]&HY_TABLE_SELECTED)			{				if (!themeFill)				{					themeFill = NewPixPat ();					checkPointer (themeFill);					Collection clcn = NewCollection();					GetTheme (clcn);					SInt32	 itemSize = sizeof (RGBColor);					long osErr = GetTaggedCollectionItem (clcn,kThemeHighlightColorTag,1,&itemSize,(void*)&fillColor);					//GetThemeBrushAsColor (kThemeBrushFocusHighlight,32,true,&fillColor);					MakeRGBPat (themeFill,&fillColor);					DisposeCollection (clcn);				}					if (chopv)					anotherRect.bottom--;				if (chop)				{					anotherRect.right-=2;					FillCRect (&anotherRect,themeFill);					anotherRect.right+=2;				}				else					FillCRect (&anotherRect,themeFill);				if (chopv)					anotherRect.bottom++;			}			if (cellTypes.lData[t3]&HY_TABLE_ICON)			{					_SimpleList		* cellList = (_SimpleList*)cellData.lData[t3];								if (w2-4>cellList->lData[1])				{					t3 = (w2-cellList->lData[1])/2;					clipRect2.left+=t3;				}				clipRect2.right = clipRect2.left+cellList->lData[1];				if (w-2>cellList->lData[2])				{					t3 = (w-cellList->lData[2])/2;					clipRect2.top+=t3;				}				clipRect2.bottom=clipRect2.top+cellList->lData[2];								if (cellList->lLength==3)					PlotCIconHandle (&clipRect2, kAlignNone,kTransformNone, (CIconHandle)cellList->lData[0]);					else				{					if ((cellList->lData[3]==HY_TABLE_COLOR_BOX)||(cellList->lData[3]==HY_TABLE_COLOR_CIRCLE))					{						PixPatHandle clr = NewPixPat ();						checkPointer (clr);						_HYColor	  c = LongToHYColor (cellList->lData[0]);						RGBColor      sysColor;						sysColor.red   = c.R*256;						sysColor.green = c.G*256;						sysColor.blue  = c.B*256;						MakeRGBPat (clr, &sysColor);						if (cellList->lData[3]==HY_TABLE_COLOR_BOX)						{							FillCRect  (&clipRect2,clr);						}						else						{							RGBColor   		trColor = {0,0,0},									   		saveFGColor;									   							::GetForeColor (&saveFGColor);																					Rect	   	   circRect = clipRect2;														RGBForeColor   (&trColor);							FrameArc	   (&circRect,0,360);																					InsetRect    (&circRect,1,1);							trColor.red = sysColor.red/2;							trColor.blue = sysColor.blue/2;							trColor.green = sysColor.green/2;							RGBForeColor   (&trColor);							FrameArc	   (&circRect,0,360);														InsetRect    (&circRect,1,1);							trColor.red = sysColor.red/1.5;							trColor.blue = sysColor.blue/1.5;							trColor.green = sysColor.green/1.5;							RGBForeColor   (&trColor);							FrameArc	   (&circRect,0,360);														InsetRect    (&circRect,1,1);							FillCArc     (&circRect,0,360,clr);							RGBForeColor   (&saveFGColor);						}						DisposePixPat (clr);					}				}										//PlotCIcon (&clipRect2, (CIconHandle)cellList->lData[0]);						}			else // text			{				st2 = cellTypes.lData[t3]&HY_TABLE_STYLEMASK;				if (st!=st2)				{					st = st2;					st2 = normal;					if (st&HY_TABLE_BOLD)						st2 = bold;					if (st&HY_TABLE_ITALIC)						st2 |= italic;					TextFace (st2);				}										_String	 *thisCell = (_String*)cellData.lData[t3];				MoveTo   (anotherRect.left+textFont.size/3, anotherRect.top+shift+textFont.size);				DrawText (thisCell->sData,0,thisCell->sLength);								if (cellTypes.lData[t3]&HY_TABLE_PULLDOWN)				{					clipRect2.right-=4;					clipRect2.left=clipRect2.right-tPDMw;					if (w-2>tPDMh)					{						t3 = (w-tPDMh)/2;						clipRect2.top+=t3;					}					clipRect2.bottom=clipRect2.top+tPDMh;					PlotCIconHandle (&clipRect2, kAlignNone,kTransformNone, tablePDMenuIcon);								//PlotCIcon (&clipRect2, tablePDMenuIcon);							}			}		}	}	if (themeFill)		DisposePixPat (themeFill);				if (offScreenPtr)	{		//SetPort 	  (thisPort);		SetGWorld (savedCPtr,savedDevice);		whiteC.red = whiteC.green = whiteC.blue = 0xffff;		RGBBackColor (&whiteC);		whiteC.red = whiteC.green = whiteC.blue = 0;		RGBForeColor (&whiteC); 			*relRect = saveRel;		OffsetRect   (&clipRect,relRect->left, relRect->top); 		#ifdef OPAQUE_TOOLBOX_STRUCTS 			CopyBits (GetPortBitMapForCopyBits(offScreenPtr),GetPortBitMapForCopyBits(GetWindowPort(parentWindow)) ,&bRect,&clipRect,srcCopy,(RgnHandle)nil); 		#else			CopyBits (&(GrafPtr(offScreenPtr)->portBits),&(parentWindow->portBits),&bRect,&clipRect,srcCopy,(RgnHandle)nil);		#endif		UnlockPixels (GetGWorldPixMap(offScreenPtr));		DisposeGWorld (offScreenPtr);	}		RGBBackColor (&oldBColor);	RGBForeColor (&oldColor);	if (editBox)	{		Rect 	temp;		SectRect(&textBoxRect,&clipRect,&temp);		if (!EmptyRect(&temp))		{			ClipRect (&clipRect);	 		if (settings.width&HY_COMPONENT_TRANSP_BG)	 		{				SetThemeWindowBackground (parentWindow,kThemeBrushWhite,false);				TEUpdate (&textBoxRect,editBox);				SetThemeWindowBackground (parentWindow,kThemeBrushDialogBackgroundActive,false);			}			else				TEUpdate (&textBoxRect,editBox);			InsetRect(&textBoxRect,1,1);			DrawThemeFocusRect (&textBoxRect,true);			InsetRect(&textBoxRect,-1,-1);		}	} 	SetClip (saveRgn); 	TextFont (savedFace); 	TextSize (savedSize); 	TextFace (savedStyle); 	DisposeRgn (saveRgn); 	 	_HYPlatformComponent::_Paint(p);}//__________________________________________________________________void		_HYPlatformTable::_SetBackColor (_HYColor& c){	RGBColor newBG;	newBG.red = c.R*0x00ff;	newBG.blue = c.B*0x00ff;	newBG.green = c.G*0x00ff;	MakeRGBPat (backPattern,&newBG);}//__________________________________________________________________void		_HYPlatformTable::_SetBackColor2 (_HYColor& c){	RGBColor newBG;	newBG.red = c.R*0x00ff;	newBG.blue = c.B*0x00ff;	newBG.green = c.G*0x00ff;	MakeRGBPat (backPattern2,&newBG);}//__________________________________________________________________void		_HYPlatformTable::_CreateTextBox (_HYRect& tBox,_String& textIn){	Rect	  destRect;	_HYTable* parent = (_HYTable*)this;		textBoxRect.left 	= tBox.left;	textBoxRect.right	= tBox.right;	textBoxRect.top		= tBox.top;	textBoxRect.bottom	= tBox.bottom;	destRect			= textBoxRect;	destRect.right 		+= 10000;	editBox 			= TEStyleNew(&destRect,&textBoxRect);	checkPointer 		((Ptr)editBox);	TESetText			(textIn.sData,textIn.sLength,editBox);	TESetSelect			(0,30000,editBox);	TextStyle			tStyle;	tStyle.tsFont		= fontID;	tStyle.tsFace		= parent->textFont.style;	tStyle.tsSize		= parent->textFont.size;	tStyle.tsColor.red	= parent->textColor.R*0x00FF;	tStyle.tsColor.green= parent->textColor.G*0x00FF;	tStyle.tsColor.blue = parent->textColor.B*0x00FF;						TESetStyle			(doAll,&tStyle,false,editBox);	TEAutoView			(true,editBox);	TECalText			(editBox);	TEActivate			(editBox);	//TEUpdate			(&textBoxRect, editBox);	}//___________________________________________________________________String		_HYPlatformTable::_RetrieveTextValue (void){	if (editBox)	{		long			textLen	= (*editBox)->teLength;		if (textLen)		{			CharsHandle 	theText = TEGetText (editBox);			_String			result  (textLen,false);			BlockMove		(*theText,result.sData,textLen);			return			result;		}	}	return		empty;}//__________________________________________________________________void		_HYPlatformTable::_KillTextBox (void){	if (editBox)	{		TEDispose (editBox);		editBox	= nil;	}}//__________________________________________________________________Rect		_HYPlatformTable::_GetVisibleRowRect (long h){	_HYTable*   parent = (_HYTable*)this;	Rect		res;		long 		w = (parent->settings.width&HY_COMPONENT_H_SCROLL)?HY_SCROLLER_WIDTH:0;	res.left   = parent->rel.left;	res.right  = (parent->settings.width&HY_COMPONENT_H_SCROLL)?parent->rel.right-HY_SCROLLER_WIDTH:parent->rel.right;		res.bottom = parent->verticalSpaces.lData[h]-parent->vOrigin+parent->rel.top;	if (res.bottom>parent->rel.bottom-w)		res.bottom=parent->rel.bottom-w;			if (h)		res.top = parent->verticalSpaces.lData[h-1]-parent->vOrigin+parent->rel.top;	else		res.top = parent->rel.top-parent->vOrigin;			return res;}//__________________________________________________________________void		_HYPlatformTable::_HiliteRowForDrag (long row, long old){	Rect		cellRect = _GetVisibleRowRect (row);	if (row<old)		cellRect.bottom = cellRect.top+2;	else		cellRect.top = cellRect.bottom-2;	InvertRect	(&cellRect);}//__________________________________________________________________void		_HYTable::_MarkCellsForUpdate (_SimpleList& cells){	GrafPtr   savePort;	GetPort   (&savePort);	#ifdef OPAQUE_TOOLBOX_STRUCTS 		SetPort   (GetWindowPort(parentWindow));	#else		SetPort   (parentWindow);	#endif	long hs,hf,vs,vf,t,t2,k;	GetDisplayRange (&rel, hs, hf, vs, vf);	Rect  clipRect;		clipRect.left = rel.left;	clipRect.right = rel.right;	if (settings.width&HY_COMPONENT_V_SCROLL)		clipRect.right -= HY_SCROLLER_WIDTH;	clipRect.top = rel.top;	clipRect.bottom = rel.bottom;	if (settings.width&HY_COMPONENT_H_SCROLL)		clipRect.bottom -= HY_SCROLLER_WIDTH;		for (k=0; k<cells.lLength; k++)	{		t2 = cells.lData[k]/horizontalSpaces.lLength;		t = cells.lData[k]%horizontalSpaces.lLength;				if ((t>=hs)&&(t<=hf)&&(t2<=vf)&&(t2>=vs))		{			//printf ("%d %d\n",t,t2);			Rect invalRect;			if (t)				invalRect.left = horizontalSpaces.lData[t-1];			else				invalRect.left = 0;			invalRect.right = horizontalSpaces.lData[t];			if (t2)				invalRect.top = verticalSpaces.lData[t2-1];			else				invalRect.top = 0;			invalRect.bottom = verticalSpaces.lData[t2];			OffsetRect (&invalRect, rel.left-hOrigin, rel.top-vOrigin);			SectRect (&invalRect, &clipRect, &invalRect);			if (!EmptyRect (&invalRect))				#ifdef TARGET_API_MAC_CARBON					InvalWindowRect (parentWindow,&invalRect);				#else					InvalRect (&invalRect);				#endif		}	}	SetPort   (savePort);}//__________________________________________________________________void		_HYTable::_MarkColumnForUpdate (long index){	long hs,hf,vs,vf;	GetDisplayRange (&rel, hs, hf, vs, vf);		if ((index>=hs)&&(index<=hf))	{		GrafPtr   savePort;		GetPort   (&savePort);		#ifdef OPAQUE_TOOLBOX_STRUCTS 			SetPort   (GetWindowPort(parentWindow));		#else			SetPort   (parentWindow);		#endif		Rect  clipRect;				clipRect.left = rel.left;		clipRect.right = rel.right;		if (settings.width&HY_COMPONENT_V_SCROLL)			clipRect.right -= HY_SCROLLER_WIDTH;		clipRect.top = rel.top;		clipRect.bottom = rel.bottom;		if (settings.width&HY_COMPONENT_H_SCROLL)			clipRect.bottom -= HY_SCROLLER_WIDTH;				Rect  invalRect;		invalRect.bottom = clipRect.bottom;		invalRect.top = clipRect.top;		invalRect.left = index?horizontalSpaces.lData[index-1]:0;		invalRect.right = horizontalSpaces.lData[index];		OffsetRect (&invalRect, rel.left-hOrigin,0);		SectRect (&invalRect, &clipRect, &invalRect);		if (!EmptyRect (&invalRect))			#ifdef TARGET_API_MAC_CARBON				InvalWindowRect (parentWindow,&invalRect);			#else				InvalRect (&invalRect);			#endif		SetPort   (savePort);	}}//__________________________________________________________________void		_HYTable::_MarkRowForUpdate (long index){	long hs,hf,vs,vf;	GetDisplayRange (&rel, hs, hf, vs, vf);		if ((index>=vs)&&(index<=vf))	{		GrafPtr   savePort;		GetPort   (&savePort);		#ifdef OPAQUE_TOOLBOX_STRUCTS 			SetPort   (GetWindowPort(parentWindow));		#else			SetPort   (parentWindow);		#endif		Rect  clipRect;				clipRect.left = rel.left;		clipRect.right = rel.right;		if (settings.width&HY_COMPONENT_V_SCROLL)			clipRect.right -= HY_SCROLLER_WIDTH;		clipRect.top = rel.top;		clipRect.bottom = rel.bottom;		if (settings.width&HY_COMPONENT_H_SCROLL)			clipRect.bottom -= HY_SCROLLER_WIDTH;				Rect  invalRect;		invalRect.right = clipRect.right;		invalRect.left = clipRect.left;		invalRect.top = index?verticalSpaces.lData[index-1]:0;		invalRect.bottom = verticalSpaces.lData[index];		OffsetRect (&invalRect, 0, rel.top-vOrigin);		SectRect (&invalRect, &clipRect, &invalRect);		#ifdef TARGET_API_MAC_CARBON			InvalWindowRect (parentWindow,&invalRect);		#else			InvalRect (&invalRect);		#endif		SetPort   (savePort);	}}//__________________________________________________________________void		_HYTable::_MarkCellForUpdate (long index){	_SimpleList 	dummy (index);	_MarkCellsForUpdate (dummy);}//__________________________________________________________________void		_HYTable::_IdleHandler (void){	if (editBox)		TEIdle (editBox);}//__________________________________________________________________long		_HYTable::_HandlePullDown (_List& data, long h, long v, long currentS){	if (data.lLength)	{		return HandlePullDownWithFont (data,h,v,currentS,textFont.face,textFont.size);	}	return -1;}//__________________________________________________________________void		_HYTable::_ScrollVPixels (long offset){	long	 voff = ((settings.width&HY_COMPONENT_H_SCROLL)?HY_SCROLLER_WIDTH:0);	offset = offset/(_Parameter)(GetMaxH()- rel.bottom+rel.top+1-voff)*MAX_CONTROL_VALUE;	ProcessEvent (generateScrollEvent(0,offset));	_SetVScrollerPos((double)MAX_CONTROL_VALUE*vOrigin/(verticalSpaces.lData[verticalSpaces.lLength-1]-vSize+voff));			}//__________________________________________________________________void		_HYTable::_ScrollHPixels (long offset){	long	 hoff = ((settings.width&HY_COMPONENT_V_SCROLL)?HY_SCROLLER_WIDTH:0);	offset = offset/(_Parameter)(GetMaxW()- rel.right+rel.bottom+1-hoff)*MAX_CONTROL_VALUE;	ProcessEvent (generateScrollEvent(offset,0));	_SetHScrollerPos((double)MAX_CONTROL_VALUE*hOrigin/(horizontalSpaces.lData[horizontalSpaces.lLength-1]-hSize+hoff));			}//__________________________________________________________________void		_HYTable::_ScrollRowIntoView (long index){	if ((index>=0)&&(index<verticalSpaces.lLength))	{		long hs, hf, vs, vf;		GetDisplayRange (&rel,hs,hf,vs,vf);		if ((index>vf)||(index<vs))			_ScrollVPixels ((index?verticalSpaces.lData[index-1]:0)-vOrigin);	}}//__________________________________________________________________void 		_HYTable::_PrintTable (_SimpleList& columns, _SimpleList& rows, _HYTable* ch){	if ((columns.lLength == 0)||(rows.lLength == 0))		return;			GrafPtr		savePort;	#ifdef		TARGET_API_MAC_CARBON		PMPrintContext thePrintingPort;		PMRect prRect;	#else		TPrStatus	prStatus;		TPPrPort	printPort;		OSErr		err;	#endif		#ifdef TARGET_API_MAC_CARBON		OSStatus theStatus;		Boolean isAccepted;				theStatus = PMBegin();		if (theStatus != noErr)			return;	#endif	if (!InitPrint())	{		_String	errMsg ("Could not initialize printing variables.");		WarnError (errMsg);		terminateExecution = false;		return;	}		GetPort(&savePort);		#ifdef TARGET_API_MAC_CARBON		if (gPrintSettings != kPMNoPrintSettings)			theStatus = PMValidatePrintSettings(gPrintSettings, kPMDontWantBoolean);		else		{			theStatus = PMNewPrintSettings(&gPrintSettings);						if ((theStatus == noErr) && (gPrintSettings != kPMNoPrintSettings))				theStatus = PMDefaultPrintSettings(gPrintSettings);		}				if (theStatus == noErr)		{			theStatus = PMPrintDialog(gPrintSettings, gPageFormat, &isAccepted);						if (isAccepted)			{				theStatus = PMGetAdjustedPageRect(gPageFormat, &prRect);				if (theStatus != noErr)					return;								theStatus = PMBeginDocument(gPrintSettings, gPageFormat, &thePrintingPort);				if (theStatus != noErr)					return;									long	 printW    = prRect.right-prRect.left-2, 						 printH    = prRect.bottom-prRect.top-2;						 				UInt32	 startPage,						 endPage;						 				PMGetFirstPage (gPrintSettings,&startPage);				PMGetLastPage  (gPrintSettings,&endPage);	#else		PrOpen();		if (err=PrError())		{			_String	errMsg ("Could not print the table. Error Code:");			errMsg = errMsg & (long)err;			WarnError (errMsg);			terminateExecution = false;			return;		}		if (PrJobDialog(prRecHdl)) 		{			printPort = PrOpenDoc(prRecHdl, nil, nil);			SetPort((GrafPtr)printPort);			long	 printW = (*prRecHdl)->prInfo.rPage.right-2, 					 printH = (*prRecHdl)->prInfo.rPage.bottom-2,					 startPage = (*prRecHdl)->prJob.iFstPage,					 endPage = (*prRecHdl)->prJob.iLstPage;	#endif		long				 tW = 0,				 tH = 0,				 cC = 0,				 cE = 0,				 cP = 1,				 t,				 i,				 pH = ch?ch->GetRowSpacing (0):0;				 						if (ch)		{			printH -= pH;			if (printH <= 0)			{				_String	errMsg ("Table header is too tall to fit on the page.");				WarnError (errMsg);				terminateExecution = false;				return;			}		}				 		_HYRect	 relDim = {0,0,0,0,HY_COMPONENT_NO_SCROLL};				if (ch)			for (i=0; i<columns.lLength; i++)				tW += ch->GetColumnSpacing (columns.lData[i]);				else			for (i=0; i<columns.lLength; i++)				tW += GetColumnSpacing (columns.lData[i]);				 		relDim.left    = relDim.right   = tW > printW ? printW : tW;				while (cP < startPage)		{			#ifdef TARGET_API_MAC_CARBON				theStatus = PMBeginPage(thePrintingPort, NULL);				if (theStatus != noErr)					break;			#else				PrOpenPage 		(printPort, nil);			#endif						t = 0;			while (cC < rows.lLength)			{				i = GetRowSpacing (rows.lData[cC]);				if ( t+i > printH)				{					cP ++;					if (i > printH)						cC++;					break;				}				else				{					t += i;					cC ++;				}			}			#if TARGET_API_MAC_CARBON					theStatus = PMEndPage(thePrintingPort);			#else					PrClosePage(printPort);			#endif				}				cE = cC;			for (long pageCount = startPage; pageCount<=endPage && (cC < rows.lLength); pageCount++)		{			t = 0;			while (cE < rows.lLength)			{				i = GetRowSpacing (rows.lData[cE]);				if ( t+i > printH)				{					if (i > printH)					{						t = printH;						cE++;					}					break;				}				else				{					t += i;					cE ++;				}			}						relDim.top = relDim.bottom = t+pH;						#ifndef TARGET_API_MAC_CARBON				_HYTable 		*thisPage = new _HYTable (relDim,(Ptr)printPort, cE-cC+(ch?1:0),columns.lLength,20,20,HY_TABLE_STATIC_TEXT);			#else				GrafPtr			prPortPtr;				PMGetGrafPtr	(thePrintingPort,&prPortPtr);				_HYTable 		*thisPage = new _HYTable (relDim,(Ptr)prPortPtr, cE-cC+(ch?1:0),columns.lLength,20,20,HY_TABLE_STATIC_TEXT);			#endif					checkPointer 	(thisPage);						#ifdef TARGET_API_MAC_CARBON				theStatus = PMBeginPage(thePrintingPort, NULL);				if (theStatus != noErr)					break;			#else				PrOpenPage 		(printPort, nil);			#endif						thisPage->SetFont       (textFont);			thisPage->SetBackColor  (backColor);			thisPage->SetBackColor2 (backColor2);			thisPage->SetTextColor	(textColor);						if (ch)				for (i=0; i<columns.lLength; i++)					thisPage->SetColumnSpacing (i,ch->GetColumnSpacing (columns.lData[i])-20, false);						else				for (i=0; i<columns.lLength; i++)					thisPage->SetColumnSpacing (i,GetColumnSpacing (columns.lData[i])-20, false);			t = 0;			if (ch)			{				thisPage->SetRowSpacing (0,pH-20,false);				for (i=0; i<columns.lLength; i++)				{					BaseRef cellData = ch->GetCellData(columns.lData[i],0);					cellData->nInstances++;					thisPage->SetCellData(cellData,0,i,ch->cellTypes.lData[columns.lData[i]]&HY_TABLE_DESELECT,false);				}				t = 1;			}						for (cP = cC; cP < cE; cP++,t++)			{				long 	 rI = rows.lData[cP];				thisPage->SetRowSpacing (t,GetRowSpacing(rI)-20,false);				for (i=0; i<columns.lLength; i++)				{					BaseRef cellData = GetCellData(columns.lData[i],rI);					cellData->nInstances++;					thisPage->SetCellData(cellData,t,i,cellTypes.lData[rI*horizontalSpaces.lLength+columns.lData[i]]&HY_TABLE_DESELECT,false);				}			} 			_HYRect relDim2 = relDim;			relDim2.left = relDim2.top = 1;			relDim2.right ++;			relDim2.bottom ++;			thisPage->_Paint ((Ptr)&relDim2);			PenSize (1,1);			RGBColor blk = {0,0,0};			RGBForeColor (&blk);			FrameRect (&HYRect2Rect (relDim2));			#if TARGET_API_MAC_CARBON					theStatus = PMEndPage(thePrintingPort);			#else					PrClosePage(printPort);			#endif					DeleteObject (thisPage);			cC = cE;		}				#ifdef TARGET_API_MAC_CARBON				theStatus = PMEndDocument(thePrintingPort);			SetPort(savePort);			if (theStatus == noErr)			{				if (gFlattenedFormat != NULL)				{					DisposeHandle(gFlattenedFormat);					gFlattenedFormat = NULL;				}								theStatus = PMFlattenPageFormat(gPageFormat, &gFlattenedFormat);			}						if (theStatus == noErr)			{				if (gFlattenedSettings != NULL)				{					DisposeHandle(gFlattenedSettings);					gFlattenedSettings = NULL;				}								theStatus = PMFlattenPrintSettings(gPrintSettings, &gFlattenedSettings);			}						if (gPageFormat != kPMNoPageFormat)			{				theStatus = PMDisposePageFormat(gPageFormat);				gPageFormat = kPMNoPageFormat;			}						if (gPrintSettings != kPMNoPrintSettings)			{				theStatus = PMDisposePrintSettings(gPrintSettings);				gPrintSettings = kPMNoPrintSettings;			}						theStatus = PMEnd();					#else			PrCloseDoc(printPort);			if (((*prRecHdl)->prJob.bJDocLoop = bSpoolLoop) && (!PrError() ) )					PrPicFile(prRecHdl, nil, nil, nil, &prStatus);		#endif	}		#ifdef TARGET_API_MAC_CARBON		}	#else		PrClose();		SetPort(savePort);	#endif}//__________________________________________________________________//  _HYPlatform Button//___________________________________________________________________HYPlatformButton::_HYPlatformButton 	(void){	backFill = NewPixPat();		if (!backFill)		warnError (-108);	RGBColor  	wht = {0xffff,0xffff,0xffff};	fontID 			= 0;	buttonControl 	= nil;	buttonRect		= (Rect){0,0,100,100};		MakeRGBPat (backFill,&wht);}		//___________________________________________________________________HYPlatformButton::~_HYPlatformButton	(void){	if (backFill)		DisposePixPat (backFill);			if (buttonControl)		DisposeControl(buttonControl);		}//__________________________________________________________________void	_HYPlatformButton::_SetBackColor (_HYColor& c){	RGBColor newBG;	newBG.red = c.R*256;	newBG.blue = c.B*256;	newBG.green = c.G*256;	MakeRGBPat (backFill,&newBG);}//__________________________________________________________________void		_HYPlatformButton::_SetFont (_HYFont& f){	Str255 fName;	StringToStr255 (f.face,fName);	short fNum=0;	GetFNum (fName,&fNum);	fontID = fNum;}//__________________________________________________________________void		_HYPlatformButton::_Update (Ptr p){	_Paint (p);}//__________________________________________________________________void		_HYPlatformButton::_SetDimensions (_HYRect r, _HYRect rel){	_HYButton* theParent = (_HYButton *) this;	theParent->_HYPlatformComponent::_SetDimensions (r,rel);	_SetVisibleSize (rel);}//__________________________________________________________________void		_HYPlatformButton::_EnableButton (bool e){	if (buttonControl)		HiliteControl (buttonControl,e?kControlNoPart:kControlInactivePart);}//__________________________________________________________________void		_HYPlatformButton::_SetButtonKind (unsigned char k){	if (buttonControl)	{		//_HYButton * theParent = (_HYButton*) this;		Boolean     onOff = (k==HY_BUTTON_OK);		SetControlData (buttonControl,						kControlNoPart,						kControlPushButtonDefaultTag,						sizeof(Boolean),						(Ptr)&onOff);			}}//__________________________________________________________________void		_HYPlatformButton::_SetVisibleSize (_HYRect rel){	_HYButton * theParent = (_HYButton*) this;		buttonRect.left=rel.left;	buttonRect.top = rel.top;		_HYRect s = theParent->_SuggestDimensions();		buttonRect.right =  buttonRect.left+s.right;	buttonRect.bottom = buttonRect.top+s.bottom;		AlignRectangle (rel, buttonRect, theParent->GetAlignFlags());		if (buttonControl)	{		SizeControl (buttonControl,buttonRect.right-buttonRect.left+1,buttonRect.bottom-buttonRect.top+1);		MoveControl (buttonControl,buttonRect.left,buttonRect.top);	}}//__________________________________________________________________void		_HYPlatformButton::_Paint (Ptr p){		_HYButton * theParent = (_HYButton*)this;	_HYRect   * relRect   = (_HYRect*)p;	Rect    	cRect; 	GrafPtr 	thisPort;		cRect.left 	 = relRect->left;	cRect.right  = relRect->right;	cRect.top 	 = relRect->top;	cRect.bottom = relRect->bottom;		if (!(theParent->settings.width&HY_COMPONENT_TRANSP_BG))		FillCRect (&cRect,backFill);	else		EraseRect (&cRect); 	if (buttonControl) 	{		GetPort   (&thisPort);		#ifdef OPAQUE_TOOLBOX_STRUCTS 			SetPort   (GetWindowPort(theParent->parentWindow));		#else			SetPort   (theParent->parentWindow);		#endif	 			#ifdef OPAQUE_TOOLBOX_STRUCTS			short	savedFace = GetPortTextFont (thisPort), 		 			savedSize = GetPortTextSize	(thisPort);		 					 	Style	savedStyle = GetPortTextFace (thisPort);		#else			short	savedFace = thisPort->txFont, 		 			savedSize = thisPort->txSize;		 					 	Style	savedStyle = thisPort->txFace;		#endif		 		 	TextFont (fontID);	 	TextSize (theParent->GetFont().size);	 	TextFace (theParent->GetFont().style);	 			Draw1Control (buttonControl);			 	TextFont 	(savedFace);	 	TextSize 	(savedSize);	 	TextFace 	(savedStyle);	 	SetPort 	(thisPort);	 } 	(*theParent)._HYPlatformComponent::_Paint(p);}//___________________________________________________________________HYRect	_HYButton::_SuggestDimensions (void){  	_HYRect res = {10,100,10,100,HY_COMPONENT_NO_SCROLL}; 	GrafPtr thisPort; 	GetPort (&thisPort); 	 	#ifdef OPAQUE_TOOLBOX_STRUCTS		short	savedFace = GetPortTextFont (thisPort), 	 			savedSize = GetPortTextSize	(thisPort);	 				 	Style	savedStyle = GetPortTextFace (thisPort);	#else		short	savedFace = thisPort->txFont, 	 			savedSize = thisPort->txSize;	 				 	Style	savedStyle = thisPort->txFace;	#endif	 	 	TextFont (fontID); 	TextSize (buttonFont.size); 	TextFace (buttonFont.style); 	 	res.top = res.bottom = buttonFont.size+8; 	res.left= res.right  = TextWidth (buttonText.sData,0,buttonText.sLength) + 15; 	 	TextFont (savedFace); 	TextSize (savedSize); 	TextFace (savedStyle); 	 	return res;}//__________________________________________________________________void		_HYButton::_Activate (void){	if (!activationFlag)		if (buttonControl&&isEnabled)		{			HiliteControl (buttonControl,0);			Draw1Control  (buttonControl);		}		_HYPlatformComponent::_Activate();}//__________________________________________________________________void		_HYButton::_Deactivate (void){	if (activationFlag)		if (buttonControl&&isEnabled)		{			HiliteControl (buttonControl, kControlInactivePart);			Draw1Control  (buttonControl);			}		_HYPlatformComponent::_Deactivate();}//__________________________________________________________________void		_HYPlatformButton::_SetText (void){	_HYButton *parent = (_HYButton*)this;		Str255 buffer;	StringToStr255 (parent->buttonText, buffer);	if (buttonControl)		SetControlTitle (buttonControl,buffer);	else	{		GrafPtr		 savePort;		GetPort (&savePort); 		#ifdef OPAQUE_TOOLBOX_STRUCTS  			SetPort (GetWindowPort(parent->parentWindow));		 		#else			SetPort (parent->parentWindow);		#endif		buttonControl = NewControl (parent->parentWindow,&buttonRect,buffer,true,0,0,0,									kControlPushButtonProc +(1<<3) ,0);									 		checkPointer ((Ptr)buttonControl);		SetPort	(savePort);	} }//__________________________________________________________________bool _HYButton::_ProcessOSEvent (Ptr vEvent){	EventRecord*	theEvent = (EventRecord*)vEvent;	WindowPtr		dummy;	if(buttonControl&&isEnabled)		switch (theEvent->what)		{			case mouseDown:			{				long evtType = FindWindow (theEvent->where,&dummy);				if (evtType == inContent)				{					Point localClick = theEvent->where;					GlobalToLocal (&localClick);					if (buttonControl&&PtInRect (localClick,&buttonRect))						if (TrackControl (buttonControl,localClick,nil))							if (messageRecipient)								messageRecipient->ProcessEvent (generateButtonPushEvent (GetID(),0));				}				return true;			}			case keyDown:			case autoKey:			{				int 	keyCode = (theEvent->message&keyCodeMask)>>8;				bool	good	= false;								if (buttonKind == HY_BUTTON_OK)					good = ((keyCode==0x24) || (keyCode==0x4C));				else					if (buttonKind == HY_BUTTON_CANCEL)						good = ((keyCode==0x35) || ((keyCode==0x2F)&&(theEvent->modifiers&cmdKey)));										if (good)				{					HiliteControl (buttonControl, kControlButtonPart);					Draw1Control  (buttonControl);					if (messageRecipient)						messageRecipient->ProcessEvent (generateButtonPushEvent (GetID(),0));					HiliteControl (buttonControl, 0);										Draw1Control  (buttonControl);				}				if (good) 					return true;			}		}				return _HYPlatformComponent::_ProcessOSEvent (vEvent);		}//__________________________________________________________________//  _HYPlatform TextBox//___________________________________________________________________HYPlatformTextBox::_HYPlatformTextBox 	(void){	backFill = NewPixPat();	backTFill = NewPixPat();		if (!(backFill&&backTFill))		warnError (-108);			te			 	= nil;		RGBColor  	wht = {0xffff,0xffff,0xffff};	MakeRGBPat (backFill,&wht);	MakeRGBPat (backTFill,&wht);		textBoxRect.left 	= textBoxRect.top 	= 0;	textBoxRect.bottom  = textBoxRect.right = 100;}		//___________________________________________________________________HYPlatformTextBox::~_HYPlatformTextBox	(void){	if (backFill)		DisposePixPat (backFill);			if (backTFill)		DisposePixPat (backTFill);	if (te)		TEDispose(te);		}//__________________________________________________________________void	_HYPlatformTextBox::_SetBackColor (_HYColor& c){	RGBColor newBG;	newBG.red  	= c.R*256;	newBG.blue 	= c.B*256;	newBG.green = c.G*256;	MakeRGBPat (backFill,&newBG);}//__________________________________________________________________void	_HYPlatformTextBox::_SetBackTColor (_HYColor& c){	RGBColor newBG;	newBG.red  	= c.R*256;	newBG.blue 	= c.B*256;	newBG.green = c.G*256;	MakeRGBPat (backTFill,&newBG);}//__________________________________________________________________void	_HYPlatformTextBox::_SetForeColor (_HYColor& c){	if (te)	{		_HYTextBox *  parent = (_HYTextBox*)this;				TextStyle 	newStyle;		newStyle.tsColor.red   = c.R*256;		newStyle.tsColor.blue  = c.B*256;		newStyle.tsColor.green = c.G*256;				if ((*te)->teLength)		{			short		ss = (*te)->selStart,						se = (*te)->selEnd;									TESetSelect (0,30000,te);			TESetStyle  (doColor,&newStyle,true,te);			TESetSelect (ss,se,te);		}		else			TESetStyle  (doColor,&newStyle,true,te);	}}//__________________________________________________________________void	_HYPlatformTextBox::_SetFont (_HYFont& f){	if (te)	{		Str255 fName;		StringToStr255 (f.face,fName);		short  fNum=0;		GetFNum (fName,&fNum);		TextStyle 	newStyle;		newStyle.tsFont = fNum;		newStyle.tsFace = f.style;		newStyle.tsSize = f.size;		if ((*te)->teLength)		{			short		ss = (*te)->selStart,						se = (*te)->selEnd;									TESetSelect (0,30000,te);			TESetStyle  (doFont|doFace|doSize,&newStyle,false,te);			TESetSelect (ss,se,te);		}		else			TESetStyle  (doFont|doFace|doSize,&newStyle,false,te);	}}//__________________________________________________________________void		_HYPlatformTextBox::_Update (Ptr p){	_Paint (p);}//__________________________________________________________________void		_HYPlatformTextBox::_SetDimensions (_HYRect r, _HYRect rel){	_HYTextBox* theParent = (_HYTextBox *) this;	theParent->_HYPlatformComponent::_SetDimensions (r,rel);	_SetVisibleSize (rel);}//__________________________________________________________________void		_HYPlatformTextBox::_SetVisibleSize (_HYRect rel){	_HYTextBox *theParent = (_HYTextBox*) this;		textBoxRect.top 	= rel.top 	+ theParent->margins.top;	textBoxRect.left 	= rel.left 	+ theParent->margins.left;	textBoxRect.bottom 	= rel.bottom- theParent->margins.bottom;	textBoxRect.right 	= rel.right - theParent->margins.right;		if ((textBoxRect.bottom-textBoxRect.top<theParent->editBoxFont.size+4)||		(textBoxRect.right-textBoxRect.left<theParent->editBoxFont.size+4))	{		if (te)		{			TEDispose (te);			te = nil;		}		return;	}			if (te)	{		CharsHandle th	= TEGetText	 (te);		Rect		textBoxRect2 = textBoxRect;		InsetRect   (&textBoxRect2,2,2);		Rect		textBoxRect3 = textBoxRect2;		if (!theParent->wrapToView)			textBoxRect3.right += 10000; 		GrafPtr thisPort; 		GetPort (&thisPort); 		#ifdef OPAQUE_TOOLBOX_STRUCTS  			SetPort (GetWindowPort(theParent->parentWindow));		 		#else			SetPort (theParent->parentWindow);		#endif				TEHandle nte = TEStyleNew (&textBoxRect3, &textBoxRect2);		checkPointer(nte);		SetPort (thisPort);		HLock ((Handle)te);		HLock (th);		short		ss = (*te)->selStart,					se = (*te)->selEnd;		TESetText 	(*th,(*te)->teLength,nte);		TESetSelect (ss,se,nte);		HUnlock 	(th);		HUnlock 	((Handle)te);		TEDispose 	(te);		te = nte;		_CreateTE();	}}//__________________________________________________________________void		_HYPlatformTextBox::_SetAlignFlags (unsigned char f){	if (te)	{		if (f&HY_ALIGN_LEFT)			TESetAlignment (teFlushLeft,te);		else			if (f&HY_ALIGN_RIGHT)				TESetAlignment (teFlushRight,te);			else					TESetAlignment (teCenter,te);	}}//___________________________________________________________________String		_HYPlatformTextBox::_GetText (void){	if (te&&(*te)->teLength)	{		_String 	result ((unsigned long)(*te)->teLength,false);		CharsHandle th = TEGetText (te);		HLock 		(th);		memcpy 		(result.sData, *th, result.sLength);		HUnlock 	(th);		return 		result;	}	return empty;}//__________________________________________________________________void		_HYPlatformTextBox::_CreateTE (void){	if (te)	{		_HYTextBox * theParent = (_HYTextBox*)this;				_SetFont 		(theParent->editBoxFont);		_SetForeColor	(theParent->foreColor);		TEAutoView  	(true, te);		TECalText		(te);		_SetAlignFlags 	(theParent->alignFlags);			if (theParent->isEnabled&&theParent->activationFlag)			TEActivate (te);			Rect			textBoxRect2 = textBoxRect;		InsetRect   	(&textBoxRect2,2,2);		TEUpdate		(&textBoxRect2,te);	}}//__________________________________________________________________void		_HYPlatformTextBox::_SetText (_String& editBoxText){	if (!te)	{		_HYTextBox * theParent = (_HYTextBox*)this;		Rect		textBoxRect2 = textBoxRect;		InsetRect   (&textBoxRect2,2,2);		Rect		textBoxRect3 = textBoxRect2;		if (!theParent->wrapToView)			textBoxRect3.right += 10000; 		GrafPtr thisPort; 		GetPort (&thisPort); 		#ifdef OPAQUE_TOOLBOX_STRUCTS  			SetPort (GetWindowPort(((_HYTextBox*)this)->parentWindow));		 		#else			SetPort (((_HYTextBox*)this)->parentWindow);		#endif		te = TEStyleNew (&textBoxRect3, &textBoxRect2);		checkPointer(te);		SetPort (thisPort);	}	TESetText	(editBoxText.sData,editBoxText.sLength,te);	_CreateTE();}//__________________________________________________________________void		_HYPlatformTextBox::_InsertText (_String& editBoxText){	if (!te)		_SetText (editBoxText);	else		TEInsert	(editBoxText.sData,editBoxText.sLength,te);}//__________________________________________________________________void		_HYPlatformTextBox::_Paint (Ptr p){		_HYTextBox * theParent = (_HYTextBox*)this;	_HYRect    * relRect   = (_HYRect*)p;	Rect    	 cRect;		 	if (te) 	{		FillCRect(&textBoxRect,backTFill);		/*RGBColor saveBack,				 newBack;		GetBackColor (&saveBack);		newBack.red = theParent->backColor.R*256;		newBack.green = theParent->backColor.G*256;		newBack.blue = theParent->backColor.B*256;		RGBBackColor (&newBack);*/	//	RGBBackColor (&saveBack);		Rect		textBoxRect2 = textBoxRect;		InsetRect   (&textBoxRect2,1,1);		DrawThemeEditTextFrame (&textBoxRect2,theParent->activationFlag?kThemeStateActive:kThemeStateInactive);		InsetRect   (&textBoxRect2,1,1); 		if (theParent->settings.width&HY_COMPONENT_TRANSP_BG) 		{			SetThemeWindowBackground (theParent->parentWindow,kThemeBrushWhite,false);			TEUpdate    (&textBoxRect2,te);			SetThemeWindowBackground (theParent->parentWindow,kThemeBrushDialogBackgroundActive,false);		}		else			TEUpdate    (&textBoxRect2,te);							if (theParent->activationFlag&&theParent->isFocused)		{			InsetRect   (&textBoxRect2,1,1);			DrawThemeFocusRect (&textBoxRect2,true);		} 	}	cRect.left 	 = relRect->left;	cRect.right  = relRect->right;	cRect.top 	 = relRect->top;	cRect.bottom = relRect->top+theParent->margins.top;	if (!(theParent->settings.width&HY_COMPONENT_TRANSP_BG))		FillCRect (&cRect,backFill);	else		EraseRect (&cRect);	cRect.bottom = relRect->bottom;	cRect.top = relRect->bottom-theParent->margins.bottom;	if (!(theParent->settings.width&HY_COMPONENT_TRANSP_BG))		FillCRect (&cRect,backFill);	else		EraseRect (&cRect);	cRect.top 	 = relRect->top;	cRect.bottom = relRect->bottom;	cRect.right  = relRect->left+theParent->margins.left;	if (!(theParent->settings.width&HY_COMPONENT_TRANSP_BG))		FillCRect (&cRect,backFill);	else		EraseRect (&cRect);	cRect.left  = relRect->right-theParent->margins.right;	cRect.right  = relRect->right;	if (!(theParent->settings.width&HY_COMPONENT_TRANSP_BG))		FillCRect (&cRect,backFill);	else		EraseRect (&cRect);	 	(*theParent)._HYPlatformComponent::_Paint(p);}//__________________________________________________________________void		_HYPlatformTextBox::_EnableTextBox (bool e){	if (te)		if (e)			TEActivate (te);		else			TEDeactivate (te);}//__________________________________________________________________void		_HYPlatformTextBox::_FocusComponent (void){	if (te)		TEActivate (te);}//__________________________________________________________________void		_HYPlatformTextBox::_UnfocusComponent (void){	if (te)		TEDeactivate (te);}//__________________________________________________________________void		_HYTextBox::_Activate (void){	if (!activationFlag)		if (te&&isEnabled)			TEActivate (te);		_HYPlatformComponent::_Activate();}//__________________________________________________________________void		_HYTextBox::_IdleHandler (void){	if (te&&isFocused)		TEIdle (te);}//__________________________________________________________________void		_HYTextBox::_Deactivate (void){	if (activationFlag)		if (te&&isEnabled)			TEDeactivate (te);		_HYPlatformComponent::_Deactivate();}//__________________________________________________________________bool _HYTextBox::_ProcessOSEvent (Ptr vEvent){	EventRecord*	theEvent = (EventRecord*)vEvent;	WindowPtr		dummy;	if (te)	{		switch (theEvent->what)		{			case mouseDown:			{				long evtType = FindWindow (theEvent->where,&dummy);				if (evtType == inContent)				{ 					if (isFocused)					{						Point localClick = theEvent->where;						GlobalToLocal (&localClick);						if (PtInRect (localClick,&textBoxRect))						{							if (settings.width&HY_COMPONENT_TRANSP_BG)								SetThemeWindowBackground (parentWindow,kThemeBrushWhite,false);							TEClick (localClick, theEvent->modifiers&shiftKey, te);		 					if (settings.width&HY_COMPONENT_TRANSP_BG)								SetThemeWindowBackground (parentWindow,kThemeBrushDialogBackgroundActive,false);							if (messageRecipient)								messageRecipient->ProcessEvent (generateTextEditChangeEvent (GetID(),0));						}					}					else						if (messageRecipient) 							messageRecipient->ProcessEvent(generateKeyboardFocusEvent(GetID())); 				}				return true;			}			case keyDown:			case autoKey:			{				if (isFocused)				{ 					if (settings.width&HY_COMPONENT_TRANSP_BG)						SetThemeWindowBackground (parentWindow,kThemeBrushWhite,false);					char c = theEvent->message&charCodeMask,						 k = (theEvent->message&keyCodeMask)>>8;						 					bool sendMessage = true;					if (theEvent->modifiers&cmdKey)					{						if ((c=='c')||(c=='C'))						{							TECopy (te);							sendMessage = false;						}						else							if ((c=='x')||(c=='X'))								TECut (te);							else								if ((c=='v')||(c=='V'))									TEPaste (te);								else									if ((c=='a')||(c=='A'))									{										SetSelection (0,30000);										sendMessage = false;									}					}					else					{						if ((k==0x24)||(k==0x4C))						{							if (messageRecipient)								messageRecipient->ProcessEvent (generateTextEditChangeEvent (GetID(),2));							return true;						}						else							TEKey (c,te);					}										if (settings.width&HY_COMPONENT_TRANSP_BG)						SetThemeWindowBackground (parentWindow,kThemeBrushDialogBackgroundActive,false);					if (messageRecipient&&sendMessage)						messageRecipient->ProcessEvent (generateTextEditChangeEvent (GetID(),1)); 					return true;				}			}		}	}		return _HYPlatformComponent::_ProcessOSEvent (vEvent);		}//__________________________________________________________________void	_HYTextBox::_SetSelection (long s, long e){	if (te&&(s>=0)&&(e>=s))		TESetSelect (s,e,te);}//__________________________________________________________________// _HYCheckbox//__________________________________________________________________void		_HYCheckbox::_Activate (void){	if (!activationFlag)		if (isEnabled&&checkboxControl)		{			HiliteControl (checkboxControl,0);			Draw1Control  (checkboxControl);		}		_HYPlatformComponent::_Activate();}//__________________________________________________________________void		_HYCheckbox::_Deactivate (void){	if (activationFlag)		if (isEnabled&&checkboxControl)		{			HiliteControl (checkboxControl, kControlInactivePart);			Draw1Control  (checkboxControl);			}		_HYPlatformComponent::_Deactivate();}//__________________________________________________________________bool _HYCheckbox::_ProcessOSEvent (Ptr vEvent){	EventRecord*	theEvent = (EventRecord*)vEvent;	WindowPtr		dummy;	if (checkboxControl)		switch (theEvent->what)		{			case mouseDown:			{				long evtType = FindWindow (theEvent->where,&dummy);				if ((evtType == inContent)&&(isEnabled))				{					Point localClick = theEvent->where;					GlobalToLocal (&localClick);					if (checkboxControl&&(PtInRect (localClick,&checkboxRect)))						if (!(isRadio&&checkState))							if (TrackControl (checkboxControl,localClick,nil))								SetState (!checkState, true);				}				return true;			}		}				return _HYPlatformComponent::_ProcessOSEvent (vEvent);		}//___________________________________________________________________HYRect		_HYCheckbox::_SuggestDimensions (void){	_HYRect res = _HYLabel::_SuggestDimensions();	if (aquaInterfaceOn)		res.left += checkSpacing*2 + 16;	else		res.left += checkSpacing*2 + 15;			res.right = res.left;	return res;}//__________________________________________________________________void		_HYPlatformCheckbox::_SetVisibleSize (_HYRect rel){	_HYCheckbox * theParent = (_HYCheckbox*) this;		theParent->labelRect.left= rel.left;	theParent->labelRect.top = rel.top;		_HYRect s = theParent->_SuggestDimensions();		theParent->labelRect.right =  theParent->labelRect.left+s.right;	theParent->labelRect.bottom = theParent->labelRect.top+s.bottom;		AlignRectangle (rel, theParent->labelRect, theParent->GetAlignFlags());		checkboxRect.left = theParent->labelRect.left + theParent->checkSpacing;	checkboxRect.bottom = theParent->labelRect.bottom;	if (aquaInterfaceOn)	{		checkboxRect.right = checkboxRect.left+16;		checkboxRect.top = checkboxRect.bottom-15;		}	else	{		checkboxRect.right = checkboxRect.left+15;		checkboxRect.top = checkboxRect.bottom-15;	}		if (aquaInterfaceOn)		theParent->labelRect.left += 16+2*theParent->checkSpacing;	else		theParent->labelRect.left += 15+2*theParent->checkSpacing;		if (checkboxControl)		MoveControl (checkboxControl,checkboxRect.left,checkboxRect.top);	else	{		GrafPtr		 savePort;		GetPort (&savePort); 		#ifdef OPAQUE_TOOLBOX_STRUCTS  			SetPort (GetWindowPort(theParent->parentWindow));		 		#else			SetPort (theParent->parentWindow);		#endif		checkboxControl = NewControl (theParent->parentWindow,&checkboxRect,"\p",true,theParent->checkState,0,1,										isRadio?kControlRadioButtonProc:kControlCheckBoxProc,0);		SetPort	(savePort);	}}//__________________________________________________________________void		_HYPlatformCheckbox::_Enable (bool e){	if (checkboxControl)	{		if (e)			HiliteControl (checkboxControl,0);		else			HiliteControl (checkboxControl,kControlInactivePart);					_HYCheckbox * theParent = (_HYCheckbox*) this;		if (e&&theParent->activationFlag)			Draw1Control  (checkboxControl);	}}//__________________________________________________________________void		_HYPlatformCheckbox::_Update (Ptr p){	_Paint (p);}//__________________________________________________________________void		_HYPlatformCheckbox::_Paint (Ptr p){	_HYCheckbox *theParent = (_HYCheckbox*) this;	theParent->_HYPlatformLabel::_Paint(p); 	if (checkboxControl) 	{ 		GrafPtr		thisPort;		GetPort   	(&thisPort); 		#ifdef OPAQUE_TOOLBOX_STRUCTS  			SetPort (GetWindowPort(theParent->parentWindow));		 		#else			SetPort (theParent->parentWindow);		#endif		Draw1Control(checkboxControl);	 	SetPort 	(thisPort);	}}//___________________________________________________________________HYPlatformCheckbox::_HYPlatformCheckbox (bool isR){	checkboxControl = nil;	isRadio = isR;	checkboxRect = (Rect){0,0,100,100};}//___________________________________________________________________HYPlatformCheckbox::~_HYPlatformCheckbox (void){	if (checkboxControl)	{		DisposeControl (checkboxControl);		checkboxControl = nil;	}}//__________________________________________________________________void	_HYPlatformCheckbox::_SetState (bool v){	if (checkboxControl)	{		SetControlValue (checkboxControl, v);	}}//EOF